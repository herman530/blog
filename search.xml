<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>一、初识 Docker 与容器</title>
      <link href="/posts/cfb7fd36/"/>
      <url>/posts/cfb7fd36/</url>
      
        <content type="html"><![CDATA[<p>如果说主机时代比拼的是单个服务器物理性能（如 CPU 主频和内存）的强弱，那么在云时代，最为看重的则是凭借虚拟化技术所构建的集群处理能力。</p><p>伴随着信息技术的飞速发展，虚拟化的概念早已经广泛应用到各种关键场景中。从 20 世纪 60 年代 IBM 推出的大型主机虚拟化，到后来以 Xen、KVM 为代表的虚拟机虚拟化，再到现在以 Docker 为代表的容器技术，虚拟化技术自身也在不断进行创新和突破。</p><p>传统来看，虚拟化既可以通过硬件模拟来实现，也可以通过操作系统软件来实现。而容器技术则更为优雅，它充分利用了操作系统本身已有的机制和特性，可以实现远超传统虚拟机的轻量级虚拟化。因此，有人甚至把它称为「新一代的虚拟化」技术，并将基于容器打造的云平台亲切地称为「容器云」。</p><p>毫无疑问，Docker 正是众多容器技术中的佼佼者，是容器技术发展过程中耀眼的一抹亮色。那么，什么是 Docker？它会带来哪些好处？它跟现有虚拟化技术又有何关系？</p><p>本章首先会介绍 Docker 项目的起源和发展过程，之后会为大家剖析 Docker 和相关容器技术，以及它为 DevOps 等场景应用带来的巨大便利。最后，还将阐述 Docker 在整个虚拟化领域中的技术定位。</p><h4 id="1-1-什么是-Docker"><a href="#1-1-什么是-Docker" class="headerlink" title="1.1　什么是 Docker"></a>1.1　什么是 Docker</h4><h5 id="1-Docker-开源项目背景"><a href="#1-Docker-开源项目背景" class="headerlink" title="1.Docker 开源项目背景"></a>1.Docker 开源项目背景</h5><p>Docker 是基于 Go 语言实现的开源容器项目。它诞生于 2013 年年初，最初发起者是 dotCloud 公司。Docker 自开源后受到业界广泛的关注和参与，目前已有 80 多个相关开源组件项目（包括 Containerd 、Moby、Swarm 等），逐渐形成了围绕 Docker 容器的完整的生态体系。</p><p>dotCloud 公司也随之快速发展壮大，在 2013 年年底直接改名为 Docker Inc ，并专注于 Docker 相关技术和产品的开发，目前已经成为全球最大的 Docker 容器服务提供商。官方网站为 docker.com。</p><p>Docker 项目已加入 Linux 基金会，并遵循 Apache 2.0 协议，全部开源代码均在 https:// github.com /docker 项目仓库进行维护。在 Linux 基金会最近一次关于「最受欢迎的云计算开源项目」的调查中，Docker 仅次于 2010 年发起的 OpenStack 项目，并仍处于上升趋势。2014 年，Docker 镜像下载数达到了一百万次，2015 年直接突破十亿次，2017 年更是突破了惊人的百亿次。</p><p>现在主流的操作系统包括 Linux 各大发行版、macOS、Windows 等都已经支持 Docker。例如， Redhat RHEL 6.5/CentOS 6.5、Ubuntu 16.04 以及更新的版本，都已经在官方软件源中默认带有 Docker 软件包。此外，各大云服务提供商也纷纷推出了基于 Docker 的服务。Google 公司在其 Platform as a Service （PaaS）平台及服务中广泛应用了 Docker 容器；IBM 公司与 Docker 公司达成了战略合作伙伴关系，进行云业务上的深入技术合作； Microsoft 公司在其 Azure 云平台上支持安全可扩展的 Docker 集群方案；公有云提供商 Amazon 在其 AWS 云平台上集成了对 Docker 的支持，提供高性能快速的部署。</p><p>Docker 的构想是要实现「Build， Ship and Run Any App ，Anywhere」，即通过对应用的封装（Packaging）、分发（ Distribution ）、部署（ Deployment ）、运行（Runtime）生命周期进行管理，达到应用组件级别的「一次封装，到处运行」。这里的应用组件，既可以是一个 Web 应用、一个编译环境，也可以是一套数据库平台服务，甚至是一个操作系统或集群。</p><p>基于 Linux 平台上的多项开源技术，Docker 提供了高效、敏捷和轻量级的容器方案，并支持部署到本地环境和多种主流云平台。可以说，Docker 首次为应用的开发、运行和部署提供了「一站式」的实用解决方案。</p><h5 id="2-Linux-容器技术——巨人的肩膀"><a href="#2-Linux-容器技术——巨人的肩膀" class="headerlink" title="2.Linux 容器技术——巨人的肩膀"></a>2.Linux 容器技术——巨人的肩膀</h5><p>与大部分新兴技术的诞生一样，Docker 也并非「从石头缝里蹦出来的」，而是站在前人的肩膀上。其中最重要的就是 Linux 容器（ Linux Containers ，LXC）技术。 IBM DeveloperWorks 网站关于容器技术的描述十分准确：「容器有效地将由单个操作系统管理的资源划分到孤立的组中，以更好地在孤立的组之间平衡有冲突的资源使用需求。与虚拟化相比，这样既不需要指令级模拟，也不需要即时编译。容器可以在核心 CPU 本地运行指令，而不需要任何专门的解释机制。此外，也避免了准虚拟化（ para-virtualization ）和系统调用替换中的复杂性。」</p><p>当然，LXC 也经历了长期的演化。最早的容器技术可以追溯到 1982 年 Unix 系列操作系统上的 chroot 工具（直到今天，主流的 Unix、Linux 操作系统仍然支持和带有该工具）。早期的容器实现技术包括 Sun Solaris 操作系统上的 Solaris Containers （2004 年发布），FreeBSD 操作系统上的 FreeBSD jail （2000 年左右发布），以及 GNU/Linux 上的 Linux-VServer （ http:// linux-vserver.org ，2001 年 10 月）和 OpenVZ（ http:// openvz.org ，2005 年）。</p><p>在 LXC 之前，这些相关技术经过多年的演化已经十分成熟和稳定，但是由于种种原因，它们并没有被很好地集成到主流的 Linux 内核中，使用起来并不方便。例如，如果用户要使用 OpenVZ 技术，需要先手动给操作系统打上特定的内核补丁方可使用，而且不同版本并不一致。类似的困难造成在很长一段时间内这些优秀的技术只在技术人员的小圈子中交流。</p><p>后来 LXC 项目借鉴了前人成熟的容器设计理念，并基于一系列新引入的内核特性，实现了更具扩展性的虚拟化容器方案。更加关键的是，LXC 终于被集成到到主流 Linux 内核中，进而成为 Linux 系统轻量级容器技术的事实标准。从技术层面来看，LXC 已经趟过了绝大部分的「坑」，完成了容器技术实用化的大半历程。</p><h5 id="3-从-Linux-容器到-Docker"><a href="#3-从-Linux-容器到-Docker" class="headerlink" title="3.从 Linux 容器到 Docker"></a>3.从 Linux 容器到 Docker</h5><p>在 LXC 的基础上，Docker 进一步优化了容器的使用体验，让它进入寻常百姓家。首先，Docker 提供了各种容器管理工具（如分发、版本、移植等），让用户无须关注底层的操作，更加简单明了地管理和使用容器；其次，Docker 通过引入分层文件系统构建和高效的镜像机制，降低了迁移难度，极大地改善了用户体验。用户操作 Docker 容器就像操作应用自身一样简单。</p><p>早期的 Docker 代码实现是直接基于 LXC 的。自 0.9 版本开始，Docker 开发了 libcon-tainer 项目作为更广泛的容器驱动实现，从而替换掉了 LXC 的实现。目前，Docker 还积极推动成立了 runC 标准项目，并贡献给开放容器联盟，试图让容器的支持不再局限于 Linux 操作系统，而是更安全、更开放、更具扩展性。</p><p>简单地讲，读者可以将 Docker 容器理解为一种轻量级的沙盒（sandbox）。每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络互相通信。容器的创建和停止十分快速，几乎跟创建和终止原生应用一致；另外，容器自身对系统资源的额外需求也十分有限，远远低于传统虚拟机。很多时候，甚至直接把容器当作应用本身也没有任何问题。</p><p>笔者相信，随着 Docker 技术的进一步成熟，它将成为更受欢迎的容器虚拟化技术实现，并在云计算和 DevOps 等领域得到更广泛的应用。</p><h4 id="1-2-为什么要使用-Docker"><a href="#1-2-为什么要使用-Docker" class="headerlink" title="1.2　为什么要使用 Docker"></a>1.2　为什么要使用 Docker</h4><h5 id="1-Docker-容器虚拟化的好处"><a href="#1-Docker-容器虚拟化的好处" class="headerlink" title="1.Docker 容器虚拟化的好处"></a>1.Docker 容器虚拟化的好处</h5><p>Docker 项目的发起人、Docker 公司 CTO Solomon Hykes 认为，Docker 在正确的地点、正确的时间顺应了正确的趋势——如何正确地构建应用。</p><p>在云时代，开发者创建的应用必须要能很方便地在网络上传播，也就是说应用必须脱离底层物理硬件的限制；同时必须是「任何时间任何地点」可获取的。因此，开发者们需要一种新型的创建分布式应用程序的方式，快速分发和部署，而这正是 Docker 所能够提供的最大优势。</p><p>举个简单的例子，假设用户试图基于最常见的 LAMP（Linux+Apache+MySQL+PHP）组合来构建网站。按照传统的做法，首先需要安装 Apache、MySQL 和 PHP 以及它们各自运行所依赖的环境；之后分别对它们进行配置（包括创建合适的用户、配置参数等）；经过大量的操作后，还需要进行功能测试，看是否工作正常；如果不正常，则进行调试追踪，意味着更多的时间代价和不可控的风险。可以想象，如果应用数目变多，事情会变得更加难以处理。</p><p>更为可怕的是，一旦需要服务器迁移（例如从亚马逊云迁移到其他云），往往需要对每个应用都进行重新部署和调试。这些琐碎而无趣的「体力活」，极大地降低了用户的工作效率。究其根源，是这些应用直接运行在底层操作系统上，无法保证同一份应用在不同的环境中行为一致。</p><p>而 Docker 提供了一种更为聪明的方式，通过容器来打包应用、解耦应用和运行平台。这意味着迁移的时候，只需要在新的服务器上启动需要的容器就可以了，无论新旧服务器是否是同一类型的平台。这无疑将帮助我们节约大量的宝贵时间，并降低部署过程出现问题的风险。</p><h5 id="2-Docker-在开发和运维中的优势"><a href="#2-Docker-在开发和运维中的优势" class="headerlink" title="2.Docker 在开发和运维中的优势"></a>2.Docker 在开发和运维中的优势</h5><p>对开发和运维（DevOps）人员来说，最梦寐以求的效果可能就是一次创建或配置，之后可以在任意地方、任意时间让应用正常运行，而 Docker 恰恰是可以实现这一终极目标的「瑞士军刀」。具体说来，在开发和运维过程中，Docker 具有如下几个方面的优势：</p><p>·更快速的交付和部署。使用 Docker，开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同的环境来部署代码。只要是开发测试过的代码，就可以确保在生产环境无缝运行。Docker 可以快速创建和删除容器，实现快速迭代，节约开发、测试、部署的大量时间。并且，整个过程全程可见，使团队更容易理解应用的创建和工作过程。</p><p>·更高效的资源利用。运行 Docker 容器不需要额外的虚拟化管理程序（ Virtual Machine Manager ，VMM，以及 Hypervisor ）的支持，Docker 是内核级的虚拟化，可以实现更高的性能，同时对资源的额外需求很低。与传统虚拟机方式相比，Docker 的性能要提高 1～2 个数量级。</p><p>·更轻松的迁移和扩展。Docker 容器几乎可以在任意的平台上运行，包括物理机、虚拟机、公有云、私有云、个人电脑、服务器等，同时支持主流的操作系统发行版本。这种兼容性让用户可以在不同平台之间轻松地迁移应用。</p><p>·更简单的更新管理。使用 Dockerfile ，只需要小小的配置修改，就可以替代以往大量的更新工作。所有修改都以增量的方式被分发和更新，从而实现自动化并且高效的容器管理。</p><h5 id="3-Docker-与虚拟机比较"><a href="#3-Docker-与虚拟机比较" class="headerlink" title="3.Docker 与虚拟机比较"></a>3.Docker 与虚拟机比较</h5><p>作为一种轻量级的虚拟化方式，Docker 在运行应用上跟传统的虚拟机方式相比具有如下显著优势：</p><p>·Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式（数分钟）要快得多；</p><p>·Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个 Docker 容器（在 IBM 服务器上已经实现了同时运行 10K 量级的容器实例）；</p><p>·Docker 通过类似 Git 设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新；</p><p>·Docker 通过 Dockerfile 支持灵活的自动化创建和部署机制，以提高工作效率，并标准化流程。</p><p>Docker 容器除了运行其中的应用外，基本不消耗额外的系统资源，在保证应用性能的同时，尽量减小系统开销。传统虚拟机方式运行 N 个不同的应用就要启用 N 个虚拟机（每个虚拟机需要单独分配独占的内存、磁盘等资源），而 Docker 只需要启动 N 个隔离得「很薄的」容器，并将应用放进容器内即可。应用获得的是接近原生的运行性能。</p><p>当然，在隔离性方面，传统的虚拟机方式提供的是相对封闭的隔离。但这并不意味着 Docker 不安全。Docker 利用 Linux 系统上的多种防护技术实现了严格的隔离可靠性，并且可以整合众多安全工具。从 1.3.0 版本开始，Docker 重点改善了容器的安全控制和镜像的安全机制，极大地提高了使用 Docker 的安全性。在已知的大规模应用中，目前尚未出现值得担忧的安全隐患。</p><p>表 1-1 比较了使用 Docker 容器技术与传统虚拟机技术的各种特性，可见容器技术在很多应用场景下都具有巨大的优势。</p><p>表 1-1　Docker 容器技术与传统虚拟机技术的比较<br><img src="https://pic3.zhimg.com/v2-1c165f5697a664ec7ceedd0793b3b3ed_r.jpg" alt="image"></p><h4 id="1-3-Docker-与虚拟化"><a href="#1-3-Docker-与虚拟化" class="headerlink" title="1.3　Docker 与虚拟化"></a>1.3　Docker 与虚拟化</h4><p>虚拟化（ virtualization ）技术是一个通用的概念，在不同领域有不同的理解。在计算领域，一般指的是计算虚拟化（ computing virtualization ），或通常说的服务器虚拟化。维基百科上的定义如下：</p><p>「在计算机技术中，虚拟化是一种资源管理技术，是将计算机的各种实体资源，如服务器、网络、内存及存储等，予以抽象、转换后呈现出来，打破实体结构间的不可切割的障碍，使用户可以用比原本的组态更好的方式来应用这些资源。」</p><p>可见，虚拟化的核心是对资源的抽象，目标往往是为了在同一个主机上同时运行多个系统或应用，从而提高系统资源的利用率，并且带来降低成本、方便管理和容错容灾等好处。</p><p>从大类上分，虚拟化技术可分为基于硬件的虚拟化和基于软件的虚拟化。其中，真正意义上的基于硬件的虚拟化技术不多见，少数如网卡中的单根多 IO 虚拟化（ Single Root I / O Virtualization and Sharing Specification ，SR-IOV）等技术，也超出了本书的讨论范畴。</p><p>基于软件的虚拟化从对象所在的层次，又可以分为应用虚拟化和平台虚拟化（通常说的虚拟机技术即属于这个范畴）。前者一般指的是一些模拟设备或诸如 Wine 这样的软件，后者又可以细分为几个子类：</p><p>·完全虚拟化。虚拟机模拟完整的底层硬件环境和特权指令的执行过程，客户操作系统无须进行修改。例如 IBM p 和 z 系列的虚拟化、 VMware Workstation 、 VirtualBox 、QEMU 等；</p><p>·硬件辅助虚拟化。利用硬件（主要是 CPU）辅助支持（目前 x86 体系结构上可用的硬件辅助虚拟化技术包括 Intel-VT 和 AMD-V）处理敏感指令来实现完全虚拟化的功能，客户操作系统无须修改，例如 VMware Workstation ，Xen，KVM；</p><p>·部分虚拟化。只针对部分硬件资源进行虚拟化，客户操作系统需要进行修改。现在有些虚拟化技术的早期版本仅支持部分虚拟化；</p><p>·超虚拟化（ paravirtualization ）。部分硬件接口以软件的形式提供给客户机操作系统，客户操作系统需要进行修改，例如早期的 Xen；</p><p>·操作系统级虚拟化。内核通过创建多个虚拟的操作系统实例（内核和库）来隔离不同的进程。容器相关技术即在这个范畴。</p><p>可见，Docker 以及其他容器技术都属于操作系统虚拟化这个范畴，操作系统虚拟化最大的特点就是不需要额外的 supervisor 支持。Docker 虚拟化方式之所以有众多优势，跟操作系统虚拟化技术自身的设计和实现是分不开的。</p><p>图 1-2 比较了 Docker 和常见的虚拟机方式的不同之处。<br><img src="https://pic4.zhimg.com/v2-43258eaef0498aebe4dbf87a5b8a6b4d_r.jpg" alt="image"><br>图 1-2　Docker 和传统的虚拟化方式的不同之处</p><p>传统方式是在硬件层面实现虚拟化，需要有额外的虚拟机管理应用和虚拟机操作系统层。Docker 容器是在操作系统层面上实现虚拟化，直接复用本地主机的操作系统，因此更加轻量级。</p><h4 id="1-4-本章小结"><a href="#1-4-本章小结" class="headerlink" title="1.4　本章小结"></a>1.4　本章小结</h4><p>本章介绍了容器虚拟化的基本概念、Docker 的诞生历史，以及容器在云时代应用分发场景下的巨大优势。</p><p>与传统的虚拟机方式相比，容器虚拟化方式在很多场景下都存在极为明显的优势。无论是系统管理员、应用开发人员、测试人员，还是运维管理人员，都应该尽快掌握 Docker，尽早享受其带来的巨大便利。</p><p>在后续章节，笔者将结合实践案例具体介绍 Docker 的安装和使用。让我们一起开启精彩的现代容器之旅吧！</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.0 都更新了什么</title>
      <link href="/posts/7014c3e5/"/>
      <url>/posts/7014c3e5/</url>
      
        <content type="html"><![CDATA[<p>2018 年 3 月 1 号 Spring Boot 2.0.0.RELEASE 正式发布，这是 Spring Boot 1.0 发布 4 年之后第一次重大修订，因此有多新功能和特性值得关注！在 Spring Boot 官方博客中我们了解到：Spring Boot 2.0 版本经历了 17 个月的开发，有 215 个不同的使用者提供了超过 6800 次的提交。</p><p>我们将 Spring Boot 2.0 更新的技术分为三类进行解读：</p><ul><li>第一类，基础环境升级；</li><li>第二类，默认软件替换和优化；</li><li>第三类，新技术的引入。</li></ul><h3 id="基础环境升级"><a href="#基础环境升级" class="headerlink" title="基础环境升级"></a>基础环境升级</h3><h4 id="最低-JDK-8，支持-JDK-9，不再支持-Java-6-和-7"><a href="#最低-JDK-8，支持-JDK-9，不再支持-Java-6-和-7" class="headerlink" title="最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7"></a>最低 JDK 8，支持 JDK 9，不再支持 Java 6 和 7</h4><p>Spring Boot 2.0 要求 Java 8 作为最低版本，许多现有的 API 已更新，以利用 Java 8 的特性。例如，接口上的默认方法，函数回调以及新的 API，如 javax.time。如果你正在使用 Java 7 或更早版本，则在开发 Spring Boot 2.0 应用程序之前，需要升级你的 JDK。</p><p>Spring Boot 2.0 通过测试可以在 JDK 9 下正常运行，同时 Spring Boot 2.0 宣布不再支持 Java 6 和 7，据我了解国内绝大部分互联网公司的基本环境还在 JDK 7 或者 6 环境下运行，考虑升级 Spring Boot 2.0 的团队需要考虑这个因素。</p><h4 id="依赖组件升级"><a href="#依赖组件升级" class="headerlink" title="依赖组件升级"></a>依赖组件升级</h4><p>Spring Boot 2.0 基于 Spring Framework 5 构建，本次 Spring Boot 的升级，同时也升级了部分其依赖的第三方组件，主要有以下几个：</p><ul><li>Jetty 9.4，Jetty 是一个开源的 Servlet 容器，它为基于 Java 的 Web 内容，例如 JSP 和 Servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。</li><li>Tomcat 8.5，Apache Tomcat 8.5.x 旨在取代 8.0.x，完全支持 Java 9。</li><li>Flyway 5，Flyway 是独立于数据库的应用、管理并跟踪数据库变更的数据库版本管理工具。用通俗的话讲，Flyway 可以像 SVN 管理不同人的代码那样，管理不同人的 SQL 脚本，从而做到数据库同步。</li><li>Hibernate 5.2，Hibernate 是一款非常流行的 ORM 框架。</li><li>Gradle 3.4，Spring Boot 的 Gradle 插件在很大程度上已被重写，有了重大的改进。</li><li>Thymeleaf 3.0，Thymeleaf 3 相对于 Thymeleaf 2 有非常大的性能提升。</li></ul><h3 id="默认软件替换和优化"><a href="#默认软件替换和优化" class="headerlink" title="默认软件替换和优化"></a>默认软件替换和优化</h3><h4 id="HikariCP"><a href="#HikariCP" class="headerlink" title="HikariCP"></a>HikariCP</h4><p>默认连接池已从 Tomcat 切换到 HikariCP，HikariCP 是一个高性能的 JDBC 连接池，Hikari 是日语“光”的意思。</p><p>HikariCP 号称是 Java 业界最快的数据库连接池，官网提供了 c3p0、dbcp2、tomcat、vibur 和 Hikari 等数据连接池的性能对比。</p><p><img src="/img/springboot1.png" alt="img"> <img src="/img/springboot1.png" alt="img"></p><p>关于 Hikari 性能为什么如此突出，官网给出的说明如下：</p><ul><li>字节码精简：优化代码，直到编译后的字节码最少，这样 CPU 缓存可以加载更多的程序代码；</li><li>优化代理和拦截器：减少代码，例如 HikariCP 的 Statement proxy 只有 100 行代码；</li><li>自定义数组类型（FastStatementList）代替 ArrayList：避免每次 get() 调用都要进行 range check，避免调用 remove() 时从头到尾的扫描；</li><li>自定义集合类型（ConcurrentBag）：提高并发读写的效率；</li><li>其他针对 BoneCP 缺陷的优化，比如对于耗时超过一个 CPU 时间片的方法调用的研究。</li></ul><h4 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h4><p>Spring Security 是 Spring 社区的一个顶级项目，也是 Spring Boot 官方推荐使用的 Security 框架。除了常规的 Authentication 和 Authorization 之外，Spring Security 还提供了诸如 ACLs、LDAP、JAAS、CAS 等高级特性以满足复杂场景下的安全需求。</p><p>没有使用 Spring Boot 之前集成起来相对比较麻烦，而 Spring Boot 中基于 Java 配置实现 Spring Security 功能。Spring Boot 2.0 极大地简化了默认的安全配置，并使添加定制安全变得简单。</p><p>Spring Boot 2.0 非常容易使用 Spring Security 5.0 保护响应式应用，当检测到 Spring Security 存在的时候会自动进行默认配置。</p><h4 id="OAuth-2-0"><a href="#OAuth-2-0" class="headerlink" title="OAuth 2.0"></a>OAuth 2.0</h4><p>OAuth 2.0 是 OAuth 协议的延续版本，但不向后兼容 OAuth 1.0，即完全废止了 OAuth1.0。OAuth 2.0 关注客户端开发者的简易性。要么通过组织在资源拥有者和 HTTP 服务商之间的被批准的交互动作代表用户，要么允许第三方应用代表用户获得访问的权限。</p><p>OAuth 2.0 是一个授权框架，或称授权标准，它可以使第三方应用程序或客户端获得对 HTTP 服务上（如 Google、GitHub ）用户帐户信息的有限访问权限。OAuth 2.0 通过将用户身份验证委派给托管用户帐户的服务以及授权客户端访问用户帐户进行工作。</p><p>Spring Boot 2.0 将 Spring Security OAuth 项目迁移到 Spring Security。不再提供单独的依赖包，Spring Boot 2.0 通过 Spring Security 5 提供 OAuth 2.0 客户端支持。</p><h4 id="Micrometer"><a href="#Micrometer" class="headerlink" title="Micrometer"></a>Micrometer</h4><p>Micrometer 是一款监控指标的度量类库，可以让你在没有供应商锁定的情况下对 JVM 的应用程序代码进行调整。</p><p>Spring Boot 2.0 增强了对 Micrometer 的集成，不再提供自己的指标 API。依靠 micrometer.io 来满足所有应用程序监视需求。</p><p>Micrometer 包括尺寸指标的支持，当与尺寸监测系统配对时，尺寸指标可以有效访问特定的指定度量标准，并且可以在其尺寸范围内向下钻取。</p><p>指标可以输出到各种系统和开箱即用的 Spring Boot 2.0，为 Atlas、Datadog、Ganglia、Graphite、Influx、JMX、New Relic、Prometheus、SignalFx、StatsD 和 Wavefront 提供支持，另外还可以使用简单的内存中度量标准。</p><p>集成后提供 JVM 指标（包括 CPU、内存、线程和 GC）、Logback、Tomcat、Spring MVC ＆ 提供 RestTemplate。</p><h4 id="Redis-默认使用-Lettuce"><a href="#Redis-默认使用-Lettuce" class="headerlink" title="Redis 默认使用 Lettuce"></a>Redis 默认使用 Lettuce</h4><p>Redis 方面默认引入了 Lettuce，替代了之前的 Jedis 作为底层的 Redis 连接方式。</p><p>Lettuce 是一个可伸缩的线程安全的 Redis 客户端，用于同步、异步和反应使用。多个线程可以共享同一个 RedisConnection，它利用优秀 Netty NIO 框架来高效地管理多个连接，支持先进的 Redis 功能，如 Sentinel、集群、流水线、自动重新连接和 Redis 数据模型。</p><p>国内使用 Jedis 的居多，看来以后要多研究 Lettuce 了。</p><h4 id="配置属性绑定"><a href="#配置属性绑定" class="headerlink" title="配置属性绑定"></a>配置属性绑定</h4><p>在 Spring Boot 2.0 中，使用 @ConfigurationProperties 的绑定机制被重新设计，限制了绑定规则，并修复了 Spring Boot 1.x 中的许多不一致的地方。</p><p>新的 Binder API 也可以直接使用 @ConfigurationProperties 在代码中。例如，下面绑定 List 中的 PersonName 对象：</p><pre><code>List&lt;PersonName&gt; people = Binder.get(environment)    .bind(&quot;my.property&quot;, Bindable.listOf(PersonName.class))    .orElseThrow(IllegalStateException::new);</code></pre><p>配置源可以像这样在 YAML 中表示：</p><pre><code>my:property:    - first-name: Jane    last-name: Doe    - first-name: John    last-name: Doe</code></pre><h4 id="转换器支持"><a href="#转换器支持" class="headerlink" title="转换器支持"></a>转换器支持</h4><p>Binding 使用了一个新的 ApplicationConversionService 类，它提供了一些额外有用的转化。最引人注目的是转换器的 Duration 类型和分隔字符串。</p><p>该 Duration 转换器允许在任一 ISO-8601 格式的持续时间，或是一个简单的字符串（如 10m，10 分钟）。现有的属性已更改为默认使用 Duration，该 @DurationUnit 注释通过设置如果没有指定所使用的单元确保向后兼容性。例如，Spring Boot 1.5 中需要秒数的属性现在必须 @DurationUnit(ChronoUnit.SECONDS) 确保一个简单的值，例如 10 实际使用的值为 10s。</p><p>分隔字符串转换允许你将简单绑定 String 到 Collection 或 Array 不必分割逗号。例如，LDAP base-dn属性用 @Delimiter(Delimiter.NONE)，所以 LDAP DN（通常包含逗号）不会被错误解释。</p><h4 id="Actuator-改进"><a href="#Actuator-改进" class="headerlink" title="Actuator 改进"></a>Actuator 改进</h4><p>在 Spring Boot 2.0 中 Actuator endpoints 有很大的改进，所有 HTTP Actuator endpoints 现在都在该/actuator路径下公开，并且生成的 JSON 有效负载得到了改进。</p><p>现在默认情况下不会暴露很多端点。如果你要从 Spring Boot 1.5 升级现有的应用，请务必查看迁移指南并特别注意该 management.endpoints.web.exposure.include 属性。</p><p>Spring Boot 2.0 改进了从许多端点返回的 JSON 有效负载。</p><p>现在许多端点都具有更精确地反映底层数据的 JSON。例如，/actuator/conditions终端（/autoconfig在 Spring Boot 1.5 中）现在有一个顶级 contexts 密钥来将结果分组 ApplicationContext。</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>对 Spring Boot 2.0 中测试进行了一些补充和调整：</p><ul><li>@WebFluxTest 已添加新注释以支持 WebFlux 应用程序的“slice”测试。</li><li>Converter 和 GenericConverter beans 现在自动扫描 @WebMvcTest 和 @WebFluxTest。</li><li>@AutoConfigureWebTestClient 已经添加到 WebTestClient 供测试使用，这个注释会自动应用于 @WebFluxTest 测试。</li><li>增加了一个新的 ApplicationContextRunner 测试实用程序，可以很容易地测试你的自动配置，我们已将大部分内部测试套件移至此新模型。</li></ul><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>还有一些小的调整和改进：</p><ul><li><p>@ConditionalOnBean 现在在确定是否满足条件时使用逻辑 AND 而不是逻辑 OR。</p></li><li><p>无条件类现在包含在自动配置中。</p></li><li><p>该 spring CLI 应用程序现在包括 encodepassword 可用于创建 Spring Security 的兼容散列密码命令。</p></li><li><p>计划任务（即 @EnableScheduling）可以使用 scheduledtasks 执行器端点进行审查。</p></li><li><p>该 loggers 驱动器终端现在允许你重新设置一个日志的默认级别。</p></li><li><p>Spring Session 用户现在可以通过 sessions 执行器端点查找和删除会话。</p></li><li><p>使用 spring-boot-starter-parent 现在基于 Maven 的应用程序-parameters默认使用标志。</p><p>  《精通 Spring Boot 42 讲》。</p></li></ul><h3 id="新技术的引入"><a href="#新技术的引入" class="headerlink" title="新技术的引入"></a>新技术的引入</h3><h4 id="支持-HTTP-2"><a href="#支持-HTTP-2" class="headerlink" title="支持 HTTP/2"></a>支持 HTTP/2</h4><p>HTTP/2 是第二代的 HTTP 协议，Spring Boot 的 Web 容器选择中 Tomcat，Undertow 和 Jetty 均已支持 HTTP/2。</p><p>相比 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化：</p><ul><li>HTTP/2 采用二进制格式传输数据，而非 HTTP/1.x 的文本格式。二进制格式在协议的解析和优化扩展上带来更多的优势和可能。</li><li>HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量；而 HTTP/1.x 每次请求，都会携带大量冗余头信息，浪费了很多带宽资源；头压缩能够很好的解决该问题。</li><li>多路复用，直白的说就是所有的请求都是通过一个 TCP 连接并发完成。HTTP/1.x 虽然通过 pipeline 也能并发请求，但是多个请求之间的响应会被阻塞的，所以 pipeline 至今也没有被普及应用，而 HTTP/2 做到了真正的并发请求。同时，流还支持优先级和流量控制。</li><li>Server Push：服务端能够更快的把资源推送给客户端。例如，服务端可以主动把 JS 和 CSS 文件推送给客户端，而不需要客户端解析 HTML 再发送这些请求，当客户端需要的时候，它已经在客户端了。</li></ul><h4 id="嵌入式-Netty-服务器"><a href="#嵌入式-Netty-服务器" class="headerlink" title="嵌入式 Netty 服务器"></a>嵌入式 Netty 服务器</h4><p>由于 WebFlux 不依赖于 Servlet API，我们现在可以首次为 Netty 作为嵌入式服务器提供支持，该 spring-boot-starter-webflux 启动 POM 将拉取 Netty 4.1 和 Ractor Netty。</p><pre><code>注意：你只能将 Netty 用作反应式服务器，不提供阻止 Servlet API 支持。</code></pre><h4 id="Kotlin的支持"><a href="#Kotlin的支持" class="headerlink" title="Kotlin的支持"></a>Kotlin的支持</h4><p>Spring Boot 2.0 现在包含对 Kotlin 1.2.x 的支持，并提供了 runApplication，一个使用 Kotlin 运行 Spring Boot 应用程序的方法。我们还公开和利用了 Kotlin 对其他 Spring 项目（如 Spring Framework，Spring Data 和 Reactor）已添加到其最近版本中的支持。</p><h4 id="JOOQ-的支持"><a href="#JOOQ-的支持" class="headerlink" title="JOOQ 的支持"></a>JOOQ 的支持</h4><p>JOOQ 是基于 Java 访问关系型数据库的工具包。JOOQ 既吸取了传统 ORM 操作数据的简单性和安全性，又保留了原生 SQL 的灵活性，它更像是介于 ORMS 和 JDBC 的中间层。对于喜欢写 SQL 的码农来说，JOOQ 可以完全满足你控制欲，可以是用 Java 代码写出 SQL 的感觉来。</p><h4 id="支持-Quartz"><a href="#支持-Quartz" class="headerlink" title="支持 Quartz"></a>支持 Quartz</h4><p>Spring Boot 1.0 并没有提供对 Quartz 的支持，之前出现了各种集成方案，Spring Boot2.0 给出了最简单的集成方式。</p><h4 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h4><p>WebFlux 模块的名称是 spring-webflux，名称中的 Flux 来源于 Reactor 中的类 Flux。Spring WebFlux 有一个全新的非堵塞的函数式 Reactive Web 框架，可以用来构建异步的、非堵塞的、事件驱动的服务，在伸缩性方面表现非常好。</p><p>非阻塞的关键预期好处是能够以小的固定数量的线程和较少的内存进行扩展。在服务器端 WebFlux 支持两种不同的编程模型：</p><ul><li>基于注解的 @Controller 和其他注解也支持 Spring MVC；</li><li>Functional 、Java 8 Lambda 风格的路由和处理。</li></ul><p><img src="/img/springboot8.png" alt="img"></p><p>默认情况下，Spring Boot 2.0 使用 Netty WebFlux，因为 Netty 在异步非阻塞空间中被广泛使用，异步非阻塞连接可以节省更多的资源，提供更高的响应度。通过比较 Servlet 3.1 非阻塞 I/O 没有太多的使用，因为使用它的成本比较高，Spring WebFlux 打开了一条实用的通路。</p><p>使用 Spring WebFlux/WebFlux.fn 提供响应式 Web 编程支持，WebFlux 是一个全新的非堵塞的函数式 Reactive Web 框架，可以用来构建异步的、非堵塞的、事件驱动的服务，在伸缩性方面表现非常好，此功能来源于 Spring 5.0。</p><p>Spring Boot 2.0 也提供了对响应式编程的自动化配置，如 Reactive Spring Data、Reactive Spring Security 等。</p><p>最后，Spring Boot 2.0 的新技术还有一个有意思的彩蛋设计，同时，我会详细解释一下 Spring Boot 1.0 到 Spring Boot 2.0 API 上的一些变化，以及关于是否需要升级 Spring Boot 的个人建议。</p><p>Spring Boot 2.0 的新技术还有一个有意思的彩蛋设计:<br><strong>Spring Boot 2.0 支持了动态 Gif 的启动 Logo 打印。</strong></p><p>在 Spring Boot 1.0 项目中 src/main/resources 路径下新建一个 banner.txt 文件，文件中写入一些字符，启动项目时就会发现默认的 Banner 被替换了，到了 Spring Boot 2.0 现在可以支持 Gif 文件的打印，Spring Boot 2.0 在项目启动的时候，会将 Gif 图片的每一个画面，按照顺序打印在日志中，所有的画面打印完毕后，才会启动 Spring Boot 项目。</p><p><img src="/img/springboot9.gif" alt="img"></p><p>项目的启动 Banner 有什么用呢，在一些大的组织或者公司中，可以利用这个特性定制自己专属的启动画面，增加团队对品牌的认同感。</p><h3 id="1-0-升级-2-0-API-变化"><a href="#1-0-升级-2-0-API-变化" class="headerlink" title="1.0 升级 2.0 API 变化"></a>1.0 升级 2.0 API 变化</h3><p>从 Spring Boot 1.0 升级到 2.0 之后，有很多的 API 已经过时，在使用的时候需要注意。</p><h4 id="启动类-SpringBootServletInitializer"><a href="#启动类-SpringBootServletInitializer" class="headerlink" title="启动类 SpringBootServletInitializer"></a>启动类 SpringBootServletInitializer</h4><p>Spring Boot 部署到 Tomcat 中去启动时需要在启动类添加 SpringBootServletInitializer，2.0 和 1.0 有区别。</p><pre><code>// 1.0import org.springframework.boot.web.support.SpringBootServletInitializer;// 2.0import org.springframework.boot.web.servlet.support.SpringBootServletInitializer;@SpringBootApplicationpublic class UserManageApplication extends SpringBootServletInitializer {    @Override    protected SpringApplicationBuilder configure(SpringApplicationBuilder application) {        return application.sources(UserManageApplication.class);    }    public static void main(String[] args) throws Exception {        SpringApplication.run(UserManageApplication.class, args);    }}</code></pre><p>Spring Boot 2.0 默认不包含 log4j，建议使用 slf4j。</p><pre><code>import org.apache.log4j.Logger;protected Logger logger = Logger.getLogger(this.getClass());</code></pre><p>改为：</p><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;protected Logger logger =  LoggerFactory.getLogger(this.getClass());</code></pre><h3 id="Thymeleaf-3-0-默认不包含布局模块"><a href="#Thymeleaf-3-0-默认不包含布局模块" class="headerlink" title="Thymeleaf 3.0 默认不包含布局模块"></a>Thymeleaf 3.0 默认不包含布局模块</h3><p>Spring Boot 2.0 中 spring-boot-starter-thymeleaf 包默认并不包含布局模块，使用 Thymeleaf 对页面进行布局时，需要单独添加布局模块，如下：</p><pre><code>&lt;dependency&gt;   &lt;groupId&gt;nz.net.ultraq.thymeleaf&lt;/groupId&gt;   &lt;artifactId&gt;thymeleaf-layout-dialect&lt;/artifactId&gt;&lt;/dependency&gt;</code></pre><p>layout:decorator 标签在 3.0 过期，推荐使用新的标签 layout:decorate 进行页面布局。</p><h4 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h4><p>大量的 Servlet 专属的 server.* 被移到了 server.servlet.* 下：</p><pre><code>Old property |    New property---|---server.context-parameters.* |    server.servlet.context-parameters.*server.context-path |    server.servlet.context-pathserver.jsp.class-name |    server.servlet.jsp.class-nameserver.jsp.init-parameters.* |    server.servlet.jsp.init-parameters.*server.jsp.registered |    server.servlet.jsp.registeredserver.servlet-path |    server.servlet.path</code></pre><p>原 spring.http.* 或 spring.server.* 下的一些参数，例如我用到了文件上传参数，已修改为 sping.servlet.multipart 下。</p><h4 id="WebMvcConfigurerAdapter-过期"><a href="#WebMvcConfigurerAdapter-过期" class="headerlink" title="WebMvcConfigurerAdapter 过期"></a>WebMvcConfigurerAdapter 过期</h4><p>Spring Boot 2.0 中将原来的 WebMvcConfigurerAdapter 替换为 WebMvcConfigurer。</p><p>1.0 中的用法：</p><pre><code>public class MyWebMvcConfigurerAdapter extends WebMvcConfigurerAdapter</code></pre><p>2.0 中的用法：</p><pre><code>public class MyWebMvcConfigurerAdapter implements WebMvcConfigurer</code></pre><h4 id="Spring-Boot-JPA-变化"><a href="#Spring-Boot-JPA-变化" class="headerlink" title="Spring Boot JPA 变化"></a>Spring Boot JPA 变化</h4><h5 id="去掉了-xxxOne-方法"><a href="#去掉了-xxxOne-方法" class="headerlink" title="去掉了 xxxOne() 方法"></a>去掉了 xxxOne() 方法</h5><p>以前的 findOne() 方法其实就是根据传入的 ID 来查找对象，所以在 Spring Boot 2.0 的 Repository 中我们可以添加 findById(long id) 来替换使用。</p><p>例如：</p><pre><code>User user=userRepository.findOne(Long id)</code></pre><p>改为手动在 userRepository 手动添加 findById(long id) 方法，使用时将 findOne() 调用改为 findById(long id)：</p><pre><code>User user=userRepository.findById(long id)</code></pre><p>delete() 方法和 findOne() 类似也被去掉了，可以使用 deleteById(Long id) 来替换，还有一个不同点是 deleteById(Long id) 默认实现返回值为 void。</p><pre><code>Long deleteById(Long id);</code></pre><p>改为：</p><pre><code>//delete 改为 void 类型void deleteById(Long id);</code></pre><p>当然我们还有一种方案可以解决上述的两种变化，就是自定义 SQL（如下），但是没有上述方案简单，不建议使用。</p><pre><code>@Query(&quot;select t from Tag t where t.tagId = :tagId&quot;)Tag getByTagId(@Param(&quot;tagId&quot;) long tagId);</code></pre><h5 id="需要指定主键的自增策略"><a href="#需要指定主键的自增策略" class="headerlink" title="需要指定主键的自增策略"></a>需要指定主键的自增策略</h5><p>Spring Boot 2.0 需要指定主键的自增策略，这个和 Spring Boot 1.0 有所区别，1.0 会使用默认的策略，如果不指定自增策略会报错。</p><pre><code>@Id@GeneratedValue(strategy= GenerationType.IDENTITY)private long id;</code></pre><h5 id="分页组件-PageRequest-变化"><a href="#分页组件-PageRequest-变化" class="headerlink" title="分页组件 PageRequest 变化"></a>分页组件 PageRequest 变化</h5><p>在 Spring Boot 2.0 中 ，方法 new PageRequest(page, size, sort) 已经过期不再推荐使用，推荐使用以下方式来构建分页信息：</p><p>Pageable pageable =PageRequest.of(page, size, Sort.by(Sort.Direction.ASC,”id”));</p><p>跟踪了一下源码发现 PageRequest.of() 方法，内部还是使用的 new PageRequest(page, size, sort)，只是最新的写法更简洁一些。</p><pre><code>public static PageRequest of(int page, int size, Sort sort) {    return new PageRequest(page, size, sort);}</code></pre><h5 id="JPA-关联查询"><a href="#JPA-关联查询" class="headerlink" title="JPA 关联查询"></a>JPA 关联查询</h5><p>在使用 Spring Boot 1.0 时，使用 JPA 关联查询时我们会构建一个接口对象来接收结果集，类似如下：</p><pre><code>public interface CollectView{   Long getId();   Long getUserId();   String getProfilePicture();   String getTitle();}</code></pre><p>在使用 Spring Boot 1.0 时，如果没有查询到对应的字段会返回空，在 Spring Boot 2.0 中会直接报空指针异常，对结果集的检查会更加严格一些。</p><pre><code>这只是目前升级过程中发现的一些问题，不代表 Spring Boot 2.0 升级中的所有问题，在随后的课程中会再一一介绍。</code></pre><h3 id="是否选择升级"><a href="#是否选择升级" class="headerlink" title="是否选择升级"></a>是否选择升级</h3><p>通过以上内容可以看出 Spring Boot 2.0 相对于 1.0 增加了很多新特性，并且最重要的是 Spring Boot 2.0 依赖的 JDK 最低版本是 1.8，估计国内大多互联网公司还没有这么激进。另外一个新的重大版本更新之后，难免会有一些小 Bug 什么的，往往需要再发布几个小版本之后，才会慢慢稳定下来。</p><p>因此我的建议是，如果不是特别需要使用 Spring Boot 2.0 上面提到的新特性，就尽量不要着急进行升级，等 Spring Boot 2.0 彻底稳定下来后再使用。如果想要升级也请先从早期的版本升级到 Spring Boot 1.5X 系列之后，再升级到 Spring Boot 2.0 版本，Spring Boot 2.0 的很多配置内容和 Spring Boot 1.0 不一致需要注意。</p><p>Spring Boot 1.0 发布之后给我们带来了全新的开发模式，Spring Boot 2.0 发布标志着 Spring Boot 已经走向成熟，对 Java 领域带来的变革已经开启！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>可以看出 Spring Boot 2.0 是历时 4 年开发出来的巨作，在 Spring Boot 1.0 的基础上进行了大量的优化，淘汰了很多过期的 API，同时引入了一大批最新的技术，这些新技术在未来的一段时间内都具有引导性。在我们学习 Spring Boot 2.0 的同时，需要同时学习 Spring Boot 2.0 引入的一些新技术，不建议大家在生产环境直接进行升级，等 Spring Boot 2.0 进一步稳定之后再升级替换。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 产生的背景和它的设计理念</title>
      <link href="/posts/b9bdaf23/"/>
      <url>/posts/b9bdaf23/</url>
      
        <content type="html"><![CDATA[<p>要了解 Spring Boot 产生的背景，我们就必须要先了解一下 Spring 的发展史，不仅因为 Spring Boot 来源于 Spring 体系，而且 Spring Boot 的诞生和 Spring 框架的发展息息相关。</p><h3 id="Spring-的发展史"><a href="#Spring-的发展史" class="headerlink" title="Spring 的发展史"></a>Spring 的发展史</h3><p>时间回到 2002 年，当时正是 Java EE 和 EJB 大行其道的时候，很多知名公司都是采用此技术方案进行项目开发。这时候有一个美国的小伙子认为 EJB 太过臃肿，并不是所有的项目都需要使用 EJB 这种大型框架，应该会有一种更好的方案来解决这个问题。</p><p>他为了证明自己的想法是正确的，在 2002 年 10 月写了一本书《Expert One-on-One J2EE》，介绍了当时 Java 企业应用程序开发的情况，并指出了 Java EE 和 EJB 组件框架中存在的一些主要缺陷。在这本书中，他提出了一个基于普通 Java 类和依赖注入的更简单的解决方案。</p><p>在书中，他展示了如何在不使用 EJB 的情况下构建高质量、可扩展的在线座位预留系统。为了构建应用程序，他编写了超过 30,000 行的基础结构代码，项目中的根包命名为 com.interface21，所以人们最初称这套开源框架为 interface21，这就是 Spring 的前身。</p><p>他是谁呢？他就是大名鼎鼎的 Rod Johnson（下图），Rod Johnson 在悉尼大学不仅获得了计算机学位，同时还获得了音乐学位，更令人吃惊的是在回到软件开发领域之前，他还获得了音乐学的博士学位。现在 Rod Johnson 已经离开了 Spring，成为了一个天使投资人，同时也是多个公司的董事，早已走上人生巅峰。</p><p>在这本书发布后，一对一的 J2EE 设计和开发一炮而红。这本书免费提供的大部分基础架构代码都是高度可重用的。2003 年 Rod Johnson 和同伴在此框架的基础上开发了一个全新的框架命名为 Spring，据 Rod Johnson 介绍 Spring 是传统 J2EE 新的开始，随后 Spring 发展进入快车道。</p><ul><li>2004 年 03 月，1.0 版发布。</li><li>2006 年 10 月，2.0 版发布。</li><li>2007 年 11 月，更名为 SpringSource，同时发布了 Spring 2.5。</li><li>2009 年 12 月，Spring 3.0 发布。</li><li>2013 年 12 月，Pivotal 宣布发布 Spring 框架 4.0。</li><li>2017 年 09 月，Spring 5.0 发布。</li></ul><h3 id="Spring-Boot-的诞生"><a href="#Spring-Boot-的诞生" class="headerlink" title="Spring Boot 的诞生"></a>Spring Boot 的诞生</h3><p>多年以来，Spring 平台饱受非议的一点就是大量的 XML 配置以及复杂的依赖管理。</p><p>随着使用 Spring 进行开发的个人和企业越来越多，Spring 也慢慢从一个单一简洁的小框架变成一个大而全的开源软件，Spring 的边界不断进行扩充，到了后来 Spring 几乎可以做任何事情，市面上主流的开源软件、中间件都有 Spring 对应组件支持，人们在享用 Spring 的便利之后，也遇到了一些问题。</p><p>Spring 每集成一个开源软件，就需要增加一些基础配置，随着开发项目的逐渐庞大，往往需要集成很多开源软件。后期使用 Spring 开发大型项目需要引入很多配置文件，导致配置工作难以理解且出错率高，到了后来人们甚至称 Spring 为配置地狱。</p><p>在 2013 年的 SpringOne 2GX 会议上，Pivotal 的 CTO Adrian Colyer 回应了这些批评，并且特别提到该平台将来的目标之一就是实现免 XML 配置的开发体验。Spring Boot 所实现的功能超出了这个任务的描述，开发人员不仅不再需要编写 XML，而且在一些场景中甚至不需要编写繁琐的 import 语句。</p><p>2013 年，微服务的概念也慢慢兴起，快速开发微小独立的应用变得更为急迫，Spring 刚好处在这样一个交叉点上，于 2013 年初启动了 Spring Boot 项目的研发。2014 年，Spring Boot 伴随着 Spring 4.0 诞生发布了第一个正式版本。</p><p>Spring Boot 并不是要成为 Spring 平台里面众多“Foundation”层项目的替代者。Spring Boot 的目标不在于为已解决的问题域提供新的解决方案，而是为平台带来另一种开发体验，从而简化对这些已有技术的使用。对于已经熟悉 Spring 生态系统的开发人员来说，Spring Boot 是一个很理想的选择；对于采用 Spring 技术的新人来说，Spring Boot 提供一种更简洁的方式来使用这些技术。</p><h3 id="Spring-Boot-开发团队"><a href="#Spring-Boot-开发团队" class="headerlink" title="Spring Boot 开发团队"></a>Spring Boot 开发团队</h3><p>我们经常会看到在介绍 Spring Boot 的时候有这么一句：Spring Boot 是由 Pivotal 团队提供的全新框架。由此我们得知 Spring Boot 是由 Pivotal 团队所研发，那么 Pivotal 团队到底是一个什么样的团队呢？其实这里的 Pivotal 团队是指 Pivotal 公司。</p><p>Pivotal 公司：致力于“改变世界构造软件的方式（We are transforming how the world builds software）”，提供云原生应用开发 PaaS 平台及服务，帮助企业客户采用敏捷软件开发方法论，从而提高软件开发人员工作效率、减少运维成本，实现数字化转型、IT 创新，并最终实现业务创新。</p><p>Pivotal 公司可谓是大牛云集，公司的开源产品有：Spring 以及 Spring 衍生产品、Web 服务器 Tomcat、缓存中间件 Redis、消息中间件 RabbitMQ、平台即服务的 Cloud Foundry、Greenplum 数据引擎、还有大名鼎鼎的 GemFire（12306 系统解决方案组件之一）。这些著名开源产品背后的开发者都在 Pivotal 公司，其研发团队汇集了全球的一流开发者，Spring Boot 为什么如此优秀，或许在这里可以找到一些答案。</p><p>回顾 Pivotal 公司的发展历史，简直就是一场商业并购大片：</p><ul><li>1989 年，罗伯·米创立 Pivotal Labs 公司，它的主营业务是帮助客户开发软件，曾给谷歌、Twitter 公司做技术支持；</li><li>2003 年，EMC 收购了 VMware；</li><li>2009 年，VMware 收购了 Spring 公司；</li><li>2012 年，EMC 以现金方式收购了 Pivotal Labs 公司；</li><li>2013 年，EMC 和 VMware 分拆出其 Cloud Foundry、Pivotal Labs、Greenplum 等云计算、大数据资源，GE 投资 1.05 亿美元，成立新公司 Pivotal；</li><li>2015 年，EMC 又被 DELL 所收购。</li></ul><p>Pivotal 公司成立之后，于 2014 年发布了 Spring Boot，2015 年发布了 Spring Cloud，2018 年 Pivotal 公司在纽约上市。我们可以通过一张图来了解 Pivotal 公司的发展史。</p><p><img src="/img/springboot5.png" alt="img"></p><h3 id="Spring-Boot-的核心：约定优于配置"><a href="#Spring-Boot-的核心：约定优于配置" class="headerlink" title="Spring Boot 的核心：约定优于配置"></a>Spring Boot 的核心：约定优于配置</h3><p>那么什么是约定优于配置呢？</p><p>约定优于配置（Convention Over Configuration），也称作按约定编程，是一种软件设计范式，旨在减少软件开发人员需做决定的数量、获得简单的好处，而又不失灵活性。</p><p>本质是说，开发人员仅需规定应用中不符约定的部分。例如，如果模型中有个名为 User 的类，那么数据库中对应的表就会默认命名为 user。只有在偏离这一约定时，例如将该表命名为“user_info”，才需写有关这个名字的配置。</p><p>我们可以按照这个思路来设想，我们约定 Controller 层就是 Web 请求层可以省略 MVC 的配置；我们约定在 Service 结尾的类自动注入事务，就可以省略了 Spring 的切面事务配置。</p><p>在 Spring 体系中，Spring Boot JPA 就是约定优于配置最佳实现之一，不需要关注表结构，我们约定类名即是表名，属性名即是表的字段，String 对应 varchar，long 对应 bigint，只有需要一些特殊要求的属性，我们再单独进行配置，按照这个约定我们可以将以前的工作大大简化。</p><p>Spring Boot 体系将约定优于配置的思想展现得淋漓尽致，小到配置文件、中间件的默认配置，大到内置容器、生态中的各种 Starters 无不遵循此设计规则。Spring Boot 鼓励各软件组织方创建自己的 Starter，创建 Starter 的核心组件之一就是 autoconfigure 模块，也是 Starter 的核心功能，在启动的时候进行自动装配，属性默认化配置。</p><p>可以说正是因为 Spring Boot 简化的配置和众多的 Starters 才让 Spring Boot 变得简单、易用、快速上手，也可以说正是约定优于配置的思想彻底落地才让 Spring Boot 走向辉煌。Spring Boot 约定优于配置的思想让 Spring Boot 项目非常容易上手，让编程变得更简单，其实编程本该很简单，简单才是编程的美。</p><h3 id="Starters"><a href="#Starters" class="headerlink" title="Starters"></a>Starters</h3><p>Spring Boot Starters 基于约定优于配置的理念来设计，Spring Boot Starter 中有两个核心组件：自动配置代码和提供自动配置模块及其它有用的依赖。也就意味着当我们项目中引入某个 Starter，即拥有了此软件的默认使用能力，除非我们需要特定的配置，一般情况下我仅需要少量的配置或者不配置即可使用组件对应的功能。</p><p>Spring Boot 由众多 Starter 组成，随着版本的推移 Starter 家族成员也与日俱增。在传统 Maven 项目中通常将一些层、组件拆分为模块来管理，以便相互依赖复用，在 Spring Boot 项目中我们则可以创建自定义 Spring Boot Starter 来达成该目的。</p><p>Spring Boot 拥有强大融合社区开源软件的能力，在没有使用 Spring Boot 之前，我们需要按照每个开源软件的特性，将对应的组件包集成到我们的开发项目中，因为每个组件的设计理念和开发团队都不一致，因此会有很多不同的调用风格在我们的项目中。</p><p>Spring Boot 整合了主流的开源软件形成了一系列的 Starter，让我们有了一致的编程体验来集成各种软件，Spring Boot 在集成的时候做了大量的优化，让我们在集成的时候往往只需要很少的配置和代码就可以完成。可以说各种 Starters 就是 Spring Boot 最大的优势之一。</p><p><strong>以下为常用的 Spring Boot Starter 列表：</strong></p><table><thead><tr><th>名称</th><th>描述</th><th>Pom</th></tr></thead><tbody><tr><td>spring-boot-starter</td><td>核心 Starter，包括自动配置支持，日志和 YAML</td><td>Pom</td></tr><tr><td>spring-boot-starter-activemq</td><td>用于使用 Apache ActiveMQ 实现 JMS 消息</td><td>Pom</td></tr><tr><td>spring-boot-starter-amqp</td><td>用于使用 Spring AMQP 和 Rabbit MQ</td><td>Pom</td></tr><tr><td>spring-boot-starter-cache</td><td>用于使用 Spring 框架的缓存支持</td><td>Pom</td></tr><tr><td>spring-boot-starter-data-elasticsearch</td><td>用于使用 ElasticSearch 搜索，分析引擎和 Spring Data ElasticSearch</td><td>Pom</td></tr><tr><td>spring-boot-starter-data-jpa</td><td>用于使用 Hibernate 实现 Spring Data JPA</td><td>Pom</td></tr><tr><td>spring-boot-starter-data-mongodb</td><td>用于使用基于文档的数据库 MongoDB 和 Spring Data MongoDB</td><td>Pom</td></tr><tr><td>spring-boot-starter-data-redis</td><td>用于使用 Spring Data Redis 和 Jedis 客户端操作键—值数据存储 Redis</td><td>Pom</td></tr><tr><td>spring-boot-starter-jta-atomikos</td><td>用于使用 Atomikos 实现 JTA 事务</td><td>Pom</td></tr><tr><td>sring-boot-starter-mail</td><td>用于使用 Java Mail 和 Spring 框架 Email 发送支持</td><td>Pom</td></tr><tr><td>spring-boot-starter-quartz</td><td>用于定时任务 Quartz 的支持</td><td>Pom</td></tr><tr><td>spring-boot-starter-security</td><td>对 Spring Security 的支持</td><td>Pom</td></tr><tr><td>spring-boot-starter-test</td><td>用于测试 Spring Boot 应用，支持常用测试类库，包括 JUnit、Hamcrest 和 Mockito</td><td>Pom</td></tr><tr><td>spring-boot-starter-thymeleaf</td><td>用于使用 Thymeleaf 模板引擎构建 MVC Web 应用</td><td>Pom</td></tr><tr><td>spring-boot-starter-validation</td><td>用于使用 Hibernate Validator 实现 Java Bean 校验</td><td>Pom</td></tr><tr><td>spring-boot-starter-web</td><td>用于使用 Spring MVC 构建 Web 应用，包括 RESTful。Tomcat 是默认的内嵌容器</td><td>Pom</td></tr><tr><td>spring-boot-starter-websocket</td><td>用于使用 Spring 框架的 WebSocket 支持构建 WebSocket 应用</td><td>Pom</td></tr></tbody></table><pre><code>这里只节选了我们最常使用的 Starter，完整的 Starter 参考这里：Spring Boot application starters。</code></pre><p>因为 Spring Boot 足够的强大，很多第三方社区都进行了主动的集成。比如：MyBatis、RabbitMQ（高级用法）等，第三方社区支持的列表，可以在这里查看 Community Contributions，可以看到社区贡献的其他 Starters 列表。</p><p>看完这些 Starters 会不会瞬间觉得 Spring Boot 很强大？几乎我们涉及的开源软件 Spring Boot 都做了支持，在 Spring Boot 环境下使用这些软件，只需要引入对应的 Starter 包即可。</p><h3 id="Spring、Spring-Boot-和-Spring-Cloud-的关系"><a href="#Spring、Spring-Boot-和-Spring-Cloud-的关系" class="headerlink" title="Spring、Spring Boot 和 Spring Cloud 的关系"></a>Spring、Spring Boot 和 Spring Cloud 的关系</h3><p>Spring 最初核心的两大核心功能 Spring IoC 和 Spring Aop 成就了 Spring，Spring 在这两大核心功能上不断地发展，才有了 Spring 事务、Spring MVC 等一系列伟大的产品，最终成就了 Spring 帝国，到了后期 Spring 几乎可以解决企业开发中的所有问题。</p><p>Spring Boot 是在强大的 Spring 帝国生态基础上面发展而来，发明 Spring Boot 不是为了取代 Spring，是为了让人们更容易的使用 Spring。所以说没有 Spring 强大的功能和生态，就不会有后期 Spring Boot 的火热，Spring Boot 使用约定优于配置的理念，重新重构了 Spring 的使用，让 Spring 后续的发展更有生命力。</p><p>Spring 并没有重复制造轮子，它只是将目前各家公司开发的比较成熟、经得起实际考验的服务框架组合起来，通过 Spring Boot 风格进行再封装并屏蔽掉复杂的配置和实现原理，最终给开发者提供了一套简单易懂、易部署、易维护的分布式系统开发工具包。</p><p>Spring Cloud 是一系列框架的有序集合，它利用 Spring Boot 的开发便利性巧妙地简化了分布式系统基础设施的开发。服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以用 Spring Boot 的开发风格做到一键启动和部署。</p><p>Spring Cloud 是为了解决微服务架构中服务治理而提供的具备一系列功能的开发框架，并且 Spring Cloud 是完全基于 Spring Boot 而开发，Spring Cloud 利用 Spring Boot 特性整合了开源行业中优秀的组件，整体对外提供了一套在微服务架构中服务治理的解决方案。</p><p>综上我们可以这样来理解，正是由于 Spring IoC 和 Spring Aop 两个强大的功能才有了 Spring，Spring 生态不断的发展才有了 Spring Boot，使用 Spring Boot 让 Spring 更易用更有生命力，Spring Cloud 是基于 Spring Boot 开发的一套微服务架构下的服务治理方案。</p><p>以下为它们之间的关系。</p><pre><code>Spring Ioc/Aop &gt; Spring &gt; Spring Boot &gt; Spring Cloud</code></pre><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>Spring Boot 诞生一方面是因为 Spring 自身发展所遇到的问题，另一方面在微服务思想诞生之际，急需要一款快速开发工具来实现微服务技术落地，在这样的背景下诞生了 Spring Boot。</p><p>Spring Boot 整体的设计思想是：约定优于配置。依赖此设计思路，Spring Boot 进行了大刀阔斧的改革，让开发、测试、部署更为便捷。众多的 Starters 成就了 Spring Boot 的发展，让使用 Spring Boot 开发项目变得更加简单。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot 2.0：Spring Boot 介绍</title>
      <link href="/posts/4c9c42f2/"/>
      <url>/posts/4c9c42f2/</url>
      
        <content type="html"><![CDATA[<h3 id="Spring-Boot-介绍"><a href="#Spring-Boot-介绍" class="headerlink" title="Spring Boot 介绍"></a>Spring Boot 介绍</h3><p>Spring Boot 是由 Pivotal 团队提供的全新框架，其设计目的是用来简化新 Spring 应用的初始搭建以及开发过程，该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。Spring Boot 默认配置了很多框架的使用方式，就像 Maven 整合了所有的 Jar 包，Spring Boot 整合了所有的框架。</p><p><strong>它的核心设计思想是：约定优于配置，Spring Boot 所有开发细节都是依据此思想进行实现的。</strong></p><p>Spring Boot 是一套全新的框架，它来自于 Spring 大家族，因此 Spring 所有具备的功能它都有并且更容易使用；同时还简化了基于 Spring 的应用开发，通过少量的代码就能创建一个独立的、产品级别的 Spring 应用。</p><p>下图展示出了 Spring Boot 在 Spring 生态中的位置：</p><p><img src="/img/springboot1.png" alt="img"></p><p>该项目主要的目的是：</p><ul><li>上手 Spring 开发更快、更广泛；</li><li>使用默认方式实现快速开发；</li><li>提供大多数项目所需的非功能特性，诸如：嵌入式服务器、安全、心跳检查、外部配置等。</li></ul><h4 id="Spring-Boot-特性"><a href="#Spring-Boot-特性" class="headerlink" title="Spring Boot 特性"></a>Spring Boot 特性</h4><pre><code>使用 Spring 项目引导页面可以在几秒构建一个项目；方便对外输出各种形式的服务，如 REST API、WebSocket、Web、Streaming、Tasks；非常简洁的安全策略集成；支持关系数据库和非关系数据库；支持运行期内嵌容器，如 Tomcat、Jetty；强大的开发包，支持热启动；自动管理依赖；自带应用监控；支持各种 IDE，如 IntelliJ IDEA、NetBeans。</code></pre><h3 id="Spring-Boot-市场热度"><a href="#Spring-Boot-市场热度" class="headerlink" title="Spring Boot 市场热度"></a>Spring Boot 市场热度</h3><p>Spring Boot 于 2014 年发布了第一个正式版本，发布之后陆续有一些开源爱好者进行了研究，并迅速喜欢上了这款开源软件，Spring Boot 在初期低调快速发展，直到 2016 年才被真正使用起来。期间很多研究 Spring Boot 的开发者，在网上写了大量文章，推动了 Spring Boot 在行业内的发展。</p><p>从 2016 年到 2018 年，是 Spring Boot 在中国发展的黄金时期，使用 Spring Boot 的企业和个人开发者越来越多，我们从 Spring Boot 关键字的百度指数可以看出。</p><p><img src="/img/springboot2.png" alt="img"></p><p>通过谷歌趋势来看 Spring Boot 在美国的使用情况发现，中国和美国使用 Spring Boot 的整体频率保持一致，看来国内技术人同步全球的技术频率越来越快。</p><p><img src="/img/springboot3.png" alt="img"></p><p>看到社区使用 Spring Boot 的热情，Spring 官方也非常重视 Spring Boot 的后续发展，已经把它作为公司最顶级的项目来推广，放到了官网上第一的位置，后续 Spring Boot 的发展也被看好。</p><p><img src="/img/springboot4.png" alt="img"></p><h3 id="Spring-Boot-和微服务架构"><a href="#Spring-Boot-和微服务架构" class="headerlink" title="Spring Boot 和微服务架构"></a>Spring Boot 和微服务架构</h3><p>微服务架构是在互联网高速发展，技术日新月异的变化以及传统架构无法适应快速变化等多重因素的推动下诞生的产物。互联网时代的产品通常有两类特点：需求变化快和用户群体庞大。在这种情况下，如何从系统架构的角度出发，构建灵活、易扩展的系统，快速应对需求的变化；在用户增加的同时如何保证系统的可伸缩性、高可用性，成为系统架构面临的挑战。</p><p>如果还按照以前传统开发模式，开发一个大而全的系统已经很难满足市场对技术的需求，这时候分而治之的思想被提了出来，于是我们从单独架构发展到分布式架构，又从分布式架构发展到 SOA 架构，服务不断地被拆分和分解，粒度也越来越小，直到微服务架构的诞生。</p><p>大约 2009 年开始，Netflix 完全重新定义了它的应用程序开发和操作模型，拉开了微服务探索的第一步，直到 2014 年 3 月 Martin Fowler 写的一篇文章 Microservices 以更加通俗易懂的形式为大家定义了什么是微服务架构。Martin Fowler 在文中阐述了对微服务架构的设想，认为微服务架构是一种架构模式，它提倡将单一应用程序划分成一组小的服务，服务之间互相协调、互相配合，为用户提供最终价值。</p><p>Spring Boot 诞生时，正处于微服务概念在慢慢酝酿中，Spring Boot 的研发融合了微服务架构的理念，实现了在 Java 领域内微服务架构落地的技术支撑。Spring Boot 在开发、测试、部署、运维等方面都做了大量的优化，使用 Spring Boot 开发项目，可以快速响应需求、独立完成开发部署上线。</p><p><strong>Spring Boot 的一系列特性有助于实现微服务架构的落地，从目前众多的技术栈对比来看它是 Java 领域微服务架构最优落地技术，没有之一。</strong></p><h3 id="为什么学习-Spring-Boot-？"><a href="#为什么学习-Spring-Boot-？" class="headerlink" title="为什么学习 Spring Boot ？"></a>为什么学习 Spring Boot ？</h3><p>Spring Boot 本身并不提供 Spring 框架的核心特性以及扩展功能，只是用于快速、敏捷地开发新一代基于 Spring 框架的应用程序。同时它集成了大量常用的第三方库配置（如 Redis、MongoDB、JPA、RabbitMQ、Quartz 等），Spring Boot 应用中这些第三方库几乎可以零配置进行开箱即用，大部分的 Spring Boot 应用都只需要非常少量的配置代码，开发者能够更加专注于业务逻辑。</p><p>使用 Spring Boot 开发项目，有以下几方面优势：</p><ul><li>Spring Boot 使开发变得简单，提供了丰富的解决方案，快速集成各种解决方案提升开发效率。</li><li>Spring Boot 使配置变得简单，提供了丰富的 Starters，集成主流开源产品往往只需要简单的配置即可。</li><li>Spring Boot 使部署变得简单，其本身内嵌启动容器，仅仅需要一个命令即可启动项目，结合 Jenkins、Docker 自动化运维非常容易实现。</li><li>Spring Boot 使监控变得简单，自带监控组件，使用 Actuator 轻松监控服务各项状态。</li></ul><p>从软件发展的角度来讲，越简单的开发模式越流行，简单的开发模式解放出更多生产力，让开发人员可以避免将精力耗费在各种配置、语法所设置的门槛上，从而更专注于业务。这点上，Spring Boot 已尽可能地简化了应用开发的门槛。</p><p>Spring Boot 所集成的技术栈，涵盖了各大互联网公司的主流技术，跟着 Spring Boot 的路线去学习，基本可以了解国内外互联网公司的技术特点。<br>总结</p><p>Spring Boot 是一套快速开发框架，在微服务架构的大环境下 Spring Boot 一经推出就受到开源社区的追捧。Spring Boot 有强大的生态整合能力，提供了众多的 Starters 包，非常方便 Spring Boot 集成第三方开源软件达到开箱即用的效果。</p><p><strong>Spring Boot 和微服务架构都是未来软件开发的大趋势，越早参与，受益越大。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (十一)：变量作用域</title>
      <link href="/posts/4d7b4c59/"/>
      <url>/posts/4d7b4c59/</url>
      
        <content type="html"><![CDATA[<p>作用域为已声明标识符所表示的常量、类型、变量、函数或包在源代码中的作用范围。</p><p>Go 语言中变量可以在三个地方声明：</p><ul><li>函数内定义的变量称为局部变量</li><li>函数外定义的变量称为全局变量</li><li>函数定义中的变量称为形式参数</li></ul><p>接下来让我们具体了解局部变量、全局变量和形式参数。</p><h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>在函数体内声明的变量称之为局部变量，它们的作用域只在函数体内，参数和返回值变量也是局部变量。</p><p>以下实例中 main() 函数使用了局部变量 a, b, c：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 声明局部变量 */   var a, b, c int    /* 初始化参数 */   a = 10   b = 20   c = a + b   fmt.Printf (&quot;结果： a = %d, b = %d and c = %d\n&quot;, a, b, c)}</code></pre><p>以上实例执行输出结果为：</p><pre><code>结果： a = 10, b = 20 and c = 30</code></pre><h4 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h4><p>在函数体外声明的变量称之为全局变量，全局变量可以在整个包甚至外部包（被导出后）使用。</p><p>全局变量可以在任何函数中使用，以下实例演示了如何使用全局变量：</p><pre><code>package mainimport &quot;fmt&quot;/* 声明全局变量 */var g intfunc main() {   /* 声明局部变量 */   var a, b int   /* 初始化参数 */   a = 10   b = 20   g = a + b   fmt.Printf(&quot;结果： a = %d, b = %d and g = %d\n&quot;, a, b, g)}</code></pre><p>以上实例执行输出结果为：</p><pre><code>结果： a = 10, b = 20 and g = 30</code></pre><p>Go 语言程序中全局变量与局部变量名称可以相同，但是函数内的局部变量会被优先考虑。实例如下：</p><pre><code>package mainimport &quot;fmt&quot;/* 声明全局变量 */var g int = 20func main() {   /* 声明局部变量 */   var g int = 10   fmt.Printf (&quot;结果： g = %d\n&quot;,  g)}</code></pre><p>以上实例执行输出结果为：</p><pre><code>结果： g = 10</code></pre><h4 id="形式参数"><a href="#形式参数" class="headerlink" title="形式参数"></a>形式参数</h4><p>形式参数会作为函数的局部变量来使用。实例如下：</p><pre><code>package mainimport &quot;fmt&quot;/* 声明全局变量 */var a int = 20;func main() {   /* main 函数中声明局部变量 */   var a int = 10   var b int = 20   var c int = 0   fmt.Printf(&quot;main()函数中 a = %d\n&quot;,  a);   c = sum( a, b);   fmt.Printf(&quot;main()函数中 c = %d\n&quot;,  c);}/* 函数定义-两数相加 */func sum(a, b int) int {   fmt.Printf(&quot;sum() 函数中 a = %d\n&quot;,  a);   fmt.Printf(&quot;sum() 函数中 b = %d\n&quot;,  b);   return a + b;}</code></pre><p>以上实例执行输出结果为：</p><pre><code>main()函数中 a = 10sum() 函数中 a = 10sum() 函数中 b = 20main()函数中 c = 30</code></pre><h4 id="初始化局部和全局变量"><a href="#初始化局部和全局变量" class="headerlink" title="初始化局部和全局变量"></a>初始化局部和全局变量</h4><p>不同类型的局部和全局变量默认值为：<br>数据类型 |    初始化默认值<br>—|—<br>int |    0<br>float32 |    0<br>pointer |    nil</p>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (十)：函数</title>
      <link href="/posts/2b3cad6a/"/>
      <url>/posts/2b3cad6a/</url>
      
        <content type="html"><![CDATA[<p>函数是基本的代码块，用于执行一个任务。</p><p>Go 语言最少有个 main() 函数。</p><p>你可以通过函数来划分不同功能，逻辑上每个函数执行的是指定的任务。</p><p>函数声明告诉了编译器函数的名称，返回类型，和参数。</p><p>Go 语言标准库提供了多种可动用的内置的函数。例如，len() 函数可以接受不同类型参数并返回该类型的长度。如果我们传入的是字符串则返回字符串的长度，如果传入的是数组，则返回数组中包含的元素个数。</p><h4 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h4><p>Go 语言函数定义格式如下：</p><pre><code>func function_name( [parameter list] ) [return_types] {   函数体}</code></pre><p>函数定义解析：</p><pre><code>func：函数由 func 开始声明function_name：函数名称，函数名和参数列表一起构成了函数签名。parameter list：参数列表，参数就像一个占位符，当函数被调用时，你可以将值传递给参数，这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数。return_types：返回类型，函数返回一列值。return_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 return_types 不是必须的。函数体：函数定义的代码集合。</code></pre><h5 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h5><p>以下实例为 max() 函数的代码，该函数传入两个整型参数 num1 和 num2，并返回这两个参数的最大值：</p><pre><code>/* 函数返回两个数的最大值 */func max(num1, num2 int) int {   /* 声明局部变量 */   var result int   if (num1 &gt; num2) {      result = num1   } else {      result = num2   }   return result }</code></pre><h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>当创建函数时，你定义了函数需要做什么，通过调用该函数来执行指定任务。</p><p>调用函数，向函数传递参数，并返回值，例如：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 100   var b int = 200   var ret int   /* 调用函数并返回最大值 */   ret = max(a, b)   fmt.Printf( &quot;最大值是 : %d\n&quot;, ret )}/* 函数返回两个数的最大值 */func max(num1, num2 int) int {   /* 定义局部变量 */   var result int   if (num1 &gt; num2) {      result = num1   } else {      result = num2   }   return result }</code></pre><p>以上实例在 main() 函数中调用 max（）函数，执行结果为：</p><pre><code>最大值是 : 200</code></pre><h4 id="函数返回多个值"><a href="#函数返回多个值" class="headerlink" title="函数返回多个值"></a>函数返回多个值</h4><p>Go 函数可以返回多个值，例如：</p><pre><code>package mainimport &quot;fmt&quot;func swap(x, y string) (string, string) {   return y, x}func main() {   a, b := swap(&quot;Mahesh&quot;, &quot;Kumar&quot;)   fmt.Println(a, b)}</code></pre><p>以上实例执行结果为：</p><pre><code>Kumar Mahesh</code></pre><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><p>函数如果使用参数，该变量可称为函数的形参。</p><p>形参就像定义在函数体内的局部变量。</p><p>调用函数，可以通过两种方式来传递参数：<br>传递类型|描述<br>–|–<br>值传递     |值传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。<br>引用传递     |引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><h5 id="函数值传递值"><a href="#函数值传递值" class="headerlink" title="函数值传递值"></a>函数值传递值</h5><p>传递是指在调用函数时将实际参数复制一份传递到函数中，这样在函数中如果对参数进行修改，将不会影响到实际参数。</p><p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。</p><p>以下定义了 swap() 函数：</p><p>/* 定义相互交换值的函数 */<br>    func swap(x, y int) int {<br>       var temp int</p><pre><code>   temp = x /* 保存 x 的值 */   x = y    /* 将 y 值赋给 x */   y = temp /* 将 temp 值赋给 y*/   return temp;}</code></pre><p>接下来，让我们使用值传递来调用 swap() 函数：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 100   var b int = 200   fmt.Printf(&quot;交换前 a 的值为 : %d\n&quot;, a )   fmt.Printf(&quot;交换前 b 的值为 : %d\n&quot;, b )   /* 通过调用函数来交换值 */   swap(a, b)   fmt.Printf(&quot;交换后 a 的值 : %d\n&quot;, a )   fmt.Printf(&quot;交换后 b 的值 : %d\n&quot;, b )}/* 定义相互交换值的函数 */func swap(x, y int) int {   var temp int   temp = x /* 保存 x 的值 */   x = y    /* 将 y 值赋给 x */   y = temp /* 将 temp 值赋给 y*/   return temp;}</code></pre><p>以下代码执行结果为：</p><pre><code>交换前 a 的值为 : 100交换前 b 的值为 : 200交换后 a 的值 : 100交换后 b 的值 : 200</code></pre><p>程序中使用的是值传递, 所以两个值并没有实现交互，我们可以使用<strong>引用传递</strong> 来实现交换效果。</p><h5 id="函数引用传递值"><a href="#函数引用传递值" class="headerlink" title="函数引用传递值"></a>函数引用传递值</h5><p>引用传递是指在调用函数时将实际参数的地址传递到函数中，那么在函数中对参数所进行的修改，将影响到实际参数。</p><p>引用传递指针参数传递到函数内，以下是交换函数 swap() 使用了引用传递：</p><pre><code>/* 定义交换值函数*/func swap(x *int, y *int) {   var temp int   temp = *x    /* 保持 x 地址上的值 */   *x = *y      /* 将 y 值赋给 x */   *y = temp    /* 将 temp 值赋给 y */}</code></pre><p>以下我们通过使用引用传递来调用 swap() 函数：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 100   var b int= 200   fmt.Printf(&quot;交换前，a 的值 : %d\n&quot;, a )   fmt.Printf(&quot;交换前，b 的值 : %d\n&quot;, b )   /* 调用 swap() 函数   * &amp;a 指向 a 指针，a 变量的地址   * &amp;b 指向 b 指针，b 变量的地址   */   swap(&amp;a, &amp;b)   fmt.Printf(&quot;交换后，a 的值 : %d\n&quot;, a )   fmt.Printf(&quot;交换后，b 的值 : %d\n&quot;, b )}func swap(x *int, y *int) {   var temp int   temp = *x    /* 保存 x 地址上的值 */   *x = *y      /* 将 y 值赋给 x */   *y = temp    /* 将 temp 值赋给 y */}</code></pre><p>以上代码执行结果为：</p><pre><code>交换前，a 的值 : 100交换前，b 的值 : 200交换后，a 的值 : 200交换后，b 的值 : 100</code></pre><p>默认情况下，Go 语言使用的是值传递，即在调用过程中不会影响到实际参数。<br>函数用法<br>函数用法 |    描述<br>–|–<br>函数作为值     |函数定义后可作为值来使用<br>闭包 |    闭包是匿名函数，可在动态编程中使用<br>方法 |    方法就是一个包含了接受者的函数</p><h5 id="函数作为值"><a href="#函数作为值" class="headerlink" title="函数作为值"></a>函数作为值</h5><p> Go 语言可以很灵活的创建函数，并作为值使用。以下实例中我们在定义的函数中初始化一个变量，该函数仅仅是为了使用内置函数 math.sqrt() ，实例为：</p><pre><code>package mainimport (   &quot;fmt&quot;   &quot;math&quot;)func main(){   /* 声明函数变量 */   getSquareRoot := func(x float64) float64 {      return math.Sqrt(x)   }   /* 使用函数 */   fmt.Println(getSquareRoot(9))}</code></pre><p>以上代码执行结果为：</p><pre><code>3</code></pre><h5 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h5><p>Go 语言支持匿名函数，可作为闭包。匿名函数是一个”内联”语句或表达式。匿名函数的优越性在于可以直接使用函数内的变量，不必申明。</p><p>以下实例中，我们创建了函数 getSequence() ，返回另外一个函数。该函数的目的是在闭包中递增 i 变量，代码如下：</p><pre><code>package mainimport &quot;fmt&quot;func getSequence() func() int {   i:=0   return func() int {      i+=1     return i     }}func main(){   /* nextNumber 为一个函数，函数 i 为 0 */   nextNumber := getSequence()     /* 调用 nextNumber 函数，i 变量自增 1 并返回 */   fmt.Println(nextNumber())   fmt.Println(nextNumber())   fmt.Println(nextNumber())   /* 创建新的函数 nextNumber1，并查看结果 */   nextNumber1 := getSequence()     fmt.Println(nextNumber1())   fmt.Println(nextNumber1())}</code></pre><p>以上代码执行结果为：</p><pre><code>12312</code></pre><h5 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h5><p>Go 语言中同时有函数和方法。一个方法就是一个包含了接受者的函数，接受者可以是命名类型或者结构体类型的一个值或者是一个指针。所有给定类型的方法属于该类型的方法集。语法格式如下：</p><pre><code>func (variable_name variable_data_type) function_name() [return_type]{   /* 函数体*/}</code></pre><p>下面定义一个结构体类型和该类型的一个方法：</p><pre><code>package mainimport (   &quot;fmt&quot;  )/* 定义结构体 */type Circle struct {  radius float64}func main() {  var c1 Circle  c1.radius = 10.00  fmt.Println(&quot;圆的面积 = &quot;, c1.getArea())}//该 method 属于 Circle 类型对象中的方法func (c Circle) getArea() float64 {  //c.radius 即为 Circle 类型对象中的属性  return 3.14 * c.radius * c.radius}</code></pre><p>以上代码执行结果为：</p><pre><code>圆的面积 =  314</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (九)：循环语句</title>
      <link href="/posts/9fd133/"/>
      <url>/posts/9fd133/</url>
      
        <content type="html"><![CDATA[<p>在不少实际问题中有许多具有规律性的重复操作，因此在程序中就需要重复执行某些语句。</p><p><img src="/img/xh1.jpg" alt="img"></p><p>以下为大多编程语言循环程序的流程图：</p><p>Go 语言提供了以下几种类型循环处理语句：</p><table><thead><tr><th>循环类型</th><th>描述</th></tr></thead><tbody><tr><td>for 循环</td><td>重复执行语句块</td></tr><tr><td>循环嵌套</td><td>在 for 循环中嵌套一个或多个 for 循环</td></tr></tbody></table><h5 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h5><p>for循环是一个循环控制结构，可以执行指定次数的循环。</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>Go语言的For循环有3中形式，只有其中的一种使用分号。</p><p>和 C 语言的 for 一样：</p><pre><code>for init; condition; post { }</code></pre><p>和 C 的 while 一样：</p><pre><code>for condition { }</code></pre><p>和 C 的 for(;;) 一样：</p><pre><code>for { }</code></pre><ol><li>init： 一般为赋值表达式，给控制变量赋初值；</li><li>condition： 关系表达式或逻辑表达式，循环控制条件；</li><li>post： 一般为赋值表达式，给控制变量增量或减量。</li></ol><p>for语句执行过程如下：</p><ol><li>先对表达式1赋初值；</li><li>判别赋值表达式 init 是否满足给定条件，若其值为真，满足循环条件，则执行循环体内语句，然后执行 post，进入第二次循环，再判别 condition；否则判断 condition 的值为假，不满足条件，就终止for循环，执行循环体外语句。</li></ol><p>for 循环的 range 格式可以对 slice、map、数组、字符串等进行迭代循环。格式如下：</p><pre><code>for key, value := range oldMap {    newMap[key] = value}</code></pre><p>for语句语法流程如下图所示：</p><p>for1.png</p><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   var b int = 15   var a int   numbers := [6]int{1, 2, 3, 5}    /* for 循环 */   for a := 0; a &lt; 10; a++ {      fmt.Printf(&quot;a 的值为: %d\n&quot;, a)   }   for a &lt; b {      a++      fmt.Printf(&quot;a 的值为: %d\n&quot;, a)   }   for i,x:= range numbers {      fmt.Printf(&quot;第 %d 位 x 的值 = %d\n&quot;, i,x)   }   }</code></pre><p>以上实例运行输出结果为:</p><pre><code>a 的值为: 0a 的值为: 1a 的值为: 2a 的值为: 3a 的值为: 4a 的值为: 5a 的值为: 6a 的值为: 7a 的值为: 8a 的值为: 9a 的值为: 1a 的值为: 2a 的值为: 3a 的值为: 4a 的值为: 5a 的值为: 6a 的值为: 7a 的值为: 8a 的值为: 9a 的值为: 10a 的值为: 11a 的值为: 12a 的值为: 13a 的值为: 14a 的值为: 15第 0 位 x 的值 = 1第 1 位 x 的值 = 2第 2 位 x 的值 = 3第 3 位 x 的值 = 5第 4 位 x 的值 = 0第 5 位 x 的值 = 0</code></pre><h5 id="循环嵌套"><a href="#循环嵌套" class="headerlink" title="循环嵌套"></a>循环嵌套</h5><p>Go 语言允许用户在循环内使用循环。接下来我们将为大家介绍嵌套循环的使用。</p><h6 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h6><p>以下为 Go 语言嵌套循环的格式：</p><pre><code>for [condition |  ( init; condition; increment ) | Range]{   for [condition |  ( init; condition; increment ) | Range]   {      statement(s);   }   statement(s);}</code></pre><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><p>以下实例使用循环嵌套来输出 2 到 100 间的素数：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var i, j int   for i=2; i &lt; 100; i++ {      for j=2; j &lt;= (i/j); j++ {         if(i%j==0) {            break; // 如果发现因子，则不是素数         }      }      if(j &gt; (i/j)) {         fmt.Printf(&quot;%d  是素数\n&quot;, i);      }   }  }</code></pre><p>以上实例运行输出结果为:</p><pre><code>2  是素数3  是素数5  是素数7  是素数11  是素数13  是素数17  是素数19  是素数23  是素数29  是素数31  是素数37  是素数41  是素数43  是素数47  是素数53  是素数59  是素数61  是素数67  是素数71  是素数73  是素数79  是素数83  是素数89  是素数97  是素数</code></pre><h4 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h4><p>循环控制语句可以控制循环体内语句的执行过程。</p><p>GO 语言支持以下几种循环控制语句：</p><table><thead><tr><th>控制语句</th><th>描述</th></tr></thead><tbody><tr><td>break 语句</td><td>经常用于中断当前 for 循环或跳出 switch 语句</td></tr><tr><td>continue 语句</td><td>跳过当前循环的剩余语句，然后继续进行下一轮循环。</td></tr><tr><td>goto 语句</td><td>将控制转移到被标记的语句。</td></tr></tbody></table><h5 id="break-语句"><a href="#break-语句" class="headerlink" title="break 语句"></a>break 语句</h5><p>Go 语言中 break 语句用于以下两方面：</p><pre><code>用于循环语句中跳出循环，并开始执行循环之后的语句。break在switch（开关语句）中在执行一条case后跳出语句的作用。</code></pre><h6 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h6><p>break 语法格式如下：</p><pre><code>break;</code></pre><p>break 语句流程图如下：</p><h6 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 10   /* for 循环 */   for a &lt; 20 {      fmt.Printf(&quot;a 的值为 : %d\n&quot;, a);      a++;      if a &gt; 15 {         /* 使用 break 语句跳出循环 */         break;      }   }}</code></pre><p>以上实例执行结果为：</p><pre><code>a 的值为 : 10a 的值为 : 11a 的值为 : 12a 的值为 : 13a 的值为 : 14a 的值为 : 15</code></pre><h5 id="continue-语句"><a href="#continue-语句" class="headerlink" title="continue 语句"></a>continue 语句</h5><p>Go 语言的 continue 语句 有点像 break 语句。但是 continue 不是跳出循环，而是跳过当前循环执行下一次循环语句。</p><p>for 循环中，执行 continue 语句会触发for增量语句的执行。</p><h6 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h6><p>continue 语法格式如下：</p><pre><code>continue;</code></pre><p>continue 语句流程图如下：</p><p><img src="/img/continue1.jpg" alt="img"></p><h6 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 10   /* for 循环 */   for a &lt; 20 {      if a == 15 {         /* 跳过此次循环 */         a = a + 1;         continue;      }      fmt.Printf(&quot;a 的值为 : %d\n&quot;, a);      a++;        }  }</code></pre><p>以上实例执行结果为：</p><pre><code>a 的值为 : 10a 的值为 : 11a 的值为 : 12a 的值为 : 13a 的值为 : 14a 的值为 : 16a 的值为 : 17a 的值为 : 18a 的值为 : 19</code></pre><h5 id="goto-语句"><a href="#goto-语句" class="headerlink" title="goto 语句"></a>goto 语句</h5><p>Go 语言的 goto 语句可以无条件地转移到过程中指定的行。</p><p>goto语句通常与条件语句配合使用。可用来实现条件转移， 构成循环，跳出循环体等功能。</p><p>但是，在结构化程序设计中一般不主张使用goto语句， 以免造成程序流程的混乱，使理解和调试程序都产生困难。</p><h6 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h6><p>goto 语法格式如下：</p><pre><code>goto label;...label: statement;</code></pre><p>break 语句流程图如下：</p><h6 id="实例-4"><a href="#实例-4" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 10   /* 循环 */   LOOP: for a &lt; 20 {      if a == 15 {         /* 跳过迭代 */         a = a + 1         goto LOOP      }      fmt.Printf(&quot;a的值为 : %d\n&quot;, a)      a++        }  }</code></pre><p>以上实例执行结果为：</p><pre><code>a的值为 : 10a的值为 : 11a的值为 : 12a的值为 : 13a的值为 : 14a的值为 : 16a的值为 : 17a的值为 : 18a的值为 : 19</code></pre><h4 id="无限循环"><a href="#无限循环" class="headerlink" title="无限循环"></a>无限循环</h4><p>如过循环中条件语句永远不为 false 则会进行无限循环，我们可以通过 for 循环语句中只设置一个条件表达式来执行无限循环：</p><pre><code>package mainimport &quot;fmt&quot;func main() {    for true  {        fmt.Printf(&quot;这是无限循环。\n&quot;);    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (八)：条件语句</title>
      <link href="/posts/b041a8d6/"/>
      <url>/posts/b041a8d6/</url>
      
        <content type="html"><![CDATA[<p>条件语句需要开发者通过指定一个或多个条件，并通过测试条件是否为 true 来决定是否执行指定语句，并在条件为 false 的情况在执行另外的语句。</p><p>下图展示了程序语言中条件语句的结构：</p><p><img src="/img/if1.jpg" alt="img"></p><p>Go 语言提供了以下几种条件判断语句：</p><table><thead><tr><th>语句</th><th>描述</th></tr></thead><tbody><tr><td>if 语句</td><td>if 语句 由一个布尔表达式后紧跟一个或多个语句组成。</td></tr><tr><td>if…else 语句</td><td>if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。</td></tr><tr><td>if 嵌套语句</td><td>你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。</td></tr><tr><td>switch 语句</td><td>switch 语句用于基于不同条件执行不同动作。</td></tr><tr><td>select 语句</td><td>select 语句类似于 switch 语句，但是select会随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。</td></tr></tbody></table><h5 id="if-语句"><a href="#if-语句" class="headerlink" title="if 语句"></a>if 语句</h5><p>if 语句由布尔表达式后紧跟一个或多个语句组成。</p><h6 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h6><p>Go 编程语言中 if 语句的语法如下：</p><pre><code>if 布尔表达式 {   /* 在布尔表达式为 true 时执行 */}</code></pre><p>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则不执行。</p><h6 id="流程图如下："><a href="#流程图如下：" class="headerlink" title="流程图如下："></a>流程图如下：</h6><p><img src="/img/if2.jpg" alt="img"></p><h6 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 10   /* 使用 if 语句判断布尔表达式 */   if a &lt; 20 {       /* 如果条件为 true 则执行以下语句 */       fmt.Printf(&quot;a 小于 20\n&quot; )   }   fmt.Printf(&quot;a 的值为 : %d\n&quot;, a)}</code></pre><p>以上代码执行结果为：</p><pre><code>a 小于 20a 的值为 : 10</code></pre><h5 id="if…else-语句"><a href="#if…else-语句" class="headerlink" title="if…else 语句"></a>if…else 语句</h5><p>if 语句 后可以使用可选的 else 语句, else 语句中的表达式在布尔表达式为 false 时执行。<br>语法</p><p>Go 编程语言中 if…else 语句的语法如下：</p><pre><code>if 布尔表达式 {   /* 在布尔表达式为 true 时执行 */} else {  /* 在布尔表达式为 false 时执行 */}</code></pre><p>If 在布尔表达式为 true 时，其后紧跟的语句块执行，如果为 false 则执行 else 语句块。</p><p>流程图如下：</p><p><img src="/img/if3.jpg" alt="img"></p><h6 id="实例-1"><a href="#实例-1" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 局部变量定义 */   var a int = 100;   /* 判断布尔表达式 */   if a &lt; 20 {       /* 如果条件为 true 则执行以下语句 */       fmt.Printf(&quot;a 小于 20\n&quot; );   } else {       /* 如果条件为 false 则执行以下语句 */       fmt.Printf(&quot;a 不小于 20\n&quot; );   }   fmt.Printf(&quot;a 的值为 : %d\n&quot;, a);}</code></pre><p>以上代码执行结果为：</p><pre><code>a 不小于 20a 的值为 : 100</code></pre><h5 id="if-嵌套语句"><a href="#if-嵌套语句" class="headerlink" title="if 嵌套语句"></a>if 嵌套语句</h5><p>你可以在 if 或 else if 语句中嵌入一个或多个 if 或 else if 语句。<br>语法</p><p>Go 编程语言中 if…else 语句的语法如下：</p><pre><code>if 布尔表达式 1 {   /* 在布尔表达式 1 为 true 时执行 */   if 布尔表达式 2 {      /* 在布尔表达式 2 为 true 时执行 */   }}</code></pre><p>你可以以同样的方式在 if 语句中嵌套 else if…else 语句<br>实例</p><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var a int = 100   var b int = 200   /* 判断条件 */   if a == 100 {       /* if 条件语句为 true 执行 */       if b == 200 {          /* if 条件语句为 true 执行 */          fmt.Printf(&quot;a 的值为 100 ， b 的值为 200\n&quot; );       }   }   fmt.Printf(&quot;a 值为 : %d\n&quot;, a );   fmt.Printf(&quot;b 值为 : %d\n&quot;, b );}</code></pre><p>以上代码执行结果为：</p><pre><code>a 的值为 100 ， b 的值为 200a 值为 : 100b 值为 : 200</code></pre><h5 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h5><p>switch 语句用于基于不同条件执行不同动作，每一个 case 分支都是唯一的，从上直下逐一测试，直到匹配为止。。</p><p>switch 语句执行的过程从上至下，直到找到匹配项，匹配项后面也不需要再加break<br>语法</p><p>Go 编程语言中 switch 语句的语法如下：</p><pre><code>switch var1 {    case val1:        ...    case val2:        ...    default:        ...}</code></pre><p>变量 var1 可以是任何类型，而 val1 和 val2 则可以是同类型的任意值。类型不被局限于常量或整数，但必须是相同的类型；或者最终结果为相同类型的表达式。</p><p>您可以同时测试多个可能符合条件的值，使用逗号分割它们，例如：case val1, val2, val3。</p><h6 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h6><p><img src="/img/if5.jpg" alt="img"></p><h6 id="实例-2"><a href="#实例-2" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   /* 定义局部变量 */   var grade string = &quot;B&quot;   var marks int = 90   switch marks {      case 90: grade = &quot;A&quot;      case 80: grade = &quot;B&quot;      case 50,60,70 : grade = &quot;C&quot;      default: grade = &quot;D&quot;     }   switch {      case grade == &quot;A&quot; :         fmt.Printf(&quot;优秀!\n&quot; )           case grade == &quot;B&quot;, grade == &quot;C&quot; :         fmt.Printf(&quot;良好\n&quot; )            case grade == &quot;D&quot; :         fmt.Printf(&quot;及格\n&quot; )            case grade == &quot;F&quot;:         fmt.Printf(&quot;不及格\n&quot; )      default:         fmt.Printf(&quot;差\n&quot; );   }   fmt.Printf(&quot;你的等级是 %s\n&quot;, grade );      }</code></pre><p>以上代码执行结果为：</p><pre><code>优秀!你的等级是 A</code></pre><h5 id="Type-Switch"><a href="#Type-Switch" class="headerlink" title="Type Switch"></a>Type Switch</h5><p>switch 语句还可以被用于 type-switch 来判断某个 interface 变量中实际存储的变量类型。</p><p>Type Switch 语法格式如下：</p><pre><code>switch x.(type){    case type:       statement(s);          case type:       statement(s);     /* 你可以定义任意个数的case */    default: /* 可选 */       statement(s);}</code></pre><p>实例</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var x interface{}   switch i := x.(type) {      case nil:               fmt.Printf(&quot; x 的类型 :%T&quot;,i)                      case int:               fmt.Printf(&quot;x 是 int 型&quot;)                             case float64:         fmt.Printf(&quot;x 是 float64 型&quot;)                 case func(int) float64:         fmt.Printf(&quot;x 是 func(int) 型&quot;)                            case bool, string:         fmt.Printf(&quot;x 是 bool 或 string 型&quot; )             default:         fmt.Printf(&quot;未知型&quot;)        }   }</code></pre><p>以上代码执行结果为：</p><pre><code>x 的类型 :&lt;nil&gt;</code></pre><h5 id="select-语句"><a href="#select-语句" class="headerlink" title="select 语句"></a>select 语句</h5><p>select是Go中的一个控制结构，类似于用于通信的switch语句。每个case必须是一个通信操作，要么是发送要么是接收。</p><p>select随机执行一个可运行的case。如果没有case可运行，它将阻塞，直到有case可运行。一个默认的子句应该总是可运行的。<br>语法</p><p>Go 编程语言中 select 语句的语法如下：</p><pre><code>select {    case communication clause  :       statement(s);          case communication clause  :       statement(s);     /* 你可以定义任意数量的 case */    default : /* 可选 */       statement(s);}</code></pre><p>以下描述了 select 语句的语法：</p><ul><li>每个case都必须是一个通信</li><li>所有channel表达式都会被求值</li><li>所有被发送的表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行；其他被忽略。</li><li>如果有多个case都可以运行，Select会随机公平地选出一个执行。其他不会执行。</li><li>否则：<ol><li>如果有default子句，则执行该语句。</li><li>如果没有default字句，select将阻塞，直到某个通信可以运行；Go不会重新对channel或值进行求值。</li></ol></li></ul><h6 id="实例-3"><a href="#实例-3" class="headerlink" title="实例"></a>实例</h6><pre><code>package mainimport &quot;fmt&quot;func main() {   var c1, c2, c3 chan int   var i1, i2 int   select {      case i1 = &lt;-c1:         fmt.Printf(&quot;received &quot;, i1, &quot; from c1\n&quot;)      case c2 &lt;- i2:         fmt.Printf(&quot;sent &quot;, i2, &quot; to c2\n&quot;)      case i3, ok := (&lt;-c3):  // same as: i3, ok := &lt;-c3         if ok {            fmt.Printf(&quot;received &quot;, i3, &quot; from c3\n&quot;)         } else {            fmt.Printf(&quot;c3 is closed\n&quot;)         }      default:         fmt.Printf(&quot;no communication\n&quot;)   }    }</code></pre><p>以上代码执行结果为：</p><pre><code>no communication</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (七)：运算符</title>
      <link href="/posts/860e6ae1/"/>
      <url>/posts/860e6ae1/</url>
      
        <content type="html"><![CDATA[<p>运算符用于在程序运行时执行数学或逻辑运算。</p><p>Go 语言内置的运算符有：</p><ul><li>算术运算符</li><li>关系运算符</li><li>逻辑运算符</li><li>位运算符</li><li>赋值运算符</li><li>其他运算符</li></ul><p>接下来让我们来详细看看各个运算符的介绍。</p><h5 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h5><p>下表列出了所有Go语言的算术运算符。假定 A 值为 10，B 值为 20。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>相加</td><td>A + B 输出结果 30</td></tr><tr><td>-</td><td>相减</td><td>A - B 输出结果 -10</td></tr><tr><td>*</td><td>相乘</td><td>A * B 输出结果 200</td></tr><tr><td>/</td><td>相除</td><td>B / A 输出结果 2</td></tr><tr><td>%</td><td>求余</td><td>B % A 输出结果 0</td></tr><tr><td>++</td><td>自增</td><td>A++ 输出结果 11</td></tr><tr><td>–</td><td>自减</td><td>A– 输出结果 9</td></tr></tbody></table><p>以下实例演示了各个算术运算符的用法：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a int = 21   var b int = 10   var c int   c = a + b   fmt.Printf(&quot;第一行 - c 的值为 %d\n&quot;, c )   c = a - b   fmt.Printf(&quot;第二行 - c 的值为 %d\n&quot;, c )   c = a * b   fmt.Printf(&quot;第三行 - c 的值为 %d\n&quot;, c )   c = a / b   fmt.Printf(&quot;第四行 - c 的值为 %d\n&quot;, c )   c = a % b   fmt.Printf(&quot;第五行 - c 的值为 %d\n&quot;, c )   a++   fmt.Printf(&quot;第六行 - a 的值为 %d\n&quot;, a )   a=21   // 为了方便测试，a 这里重新赋值为 21   a--   fmt.Printf(&quot;第七行 - a 的值为 %d\n&quot;, a )}</code></pre><p>以上实例运行结果：</p><pre><code>第一行 - c 的值为 31第二行 - c 的值为 11第三行 - c 的值为 210第四行 - c 的值为 2第五行 - c 的值为 1第六行 - a 的值为 22第七行 - a 的值为 20</code></pre><h5 id="关系运算符"><a href="#关系运算符" class="headerlink" title="关系运算符"></a>关系运算符</h5><p>下表列出了所有Go语言的关系运算符。假定 A 值为 10，B 值为 20。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>检查两个值是否相等，如果相等返回 True 否则返回 False。</td><td>(A == B) 为 False</td></tr><tr><td>!=</td><td>检查两个值是否不相等，如果不相等返回 True 否则返回 False。</td><td>(A != B) 为 True</td></tr><tr><td>&gt;</td><td>检查左边值是否大于右边值，如果是返回 True 否则返回 False。</td><td>(A &gt; B) 为 False</td></tr><tr><td>&lt;</td><td>检查左边值是否小于右边值，如果是返回 True 否则返回 False。</td><td>(A &lt; B) 为 True</td></tr><tr><td>&gt;=</td><td>检查左边值是否大于等于右边值，如果是返回 True 否则返回 False。</td><td>(A &gt;= B) 为 False</td></tr><tr><td>&lt;=</td><td>检查左边值是否小于等于右边值，如果是返回 True 否则返回 False。</td><td>(A &lt;= B) 为 True</td></tr></tbody></table><p>以下实例演示了关系运算符的用法：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a int = 21   var b int = 10   if( a == b ) {      fmt.Printf(&quot;第一行 - a 等于 b\n&quot; )   } else {      fmt.Printf(&quot;第一行 - a 不等于 b\n&quot; )   }   if ( a &lt; b ) {      fmt.Printf(&quot;第二行 - a 小于 b\n&quot; )   } else {      fmt.Printf(&quot;第二行 - a 不小于 b\n&quot; )   }    if ( a &gt; b ) {      fmt.Printf(&quot;第三行 - a 大于 b\n&quot; )   } else {      fmt.Printf(&quot;第三行 - a 不大于 b\n&quot; )   }   /* Lets change value of a and b */   a = 5   b = 20   if ( a &lt;= b ) {      fmt.Printf(&quot;第四行 - a 小于等于 b\n&quot; )   }   if ( b &gt;= a ) {      fmt.Printf(&quot;第五行 - b 大于等于 a\n&quot; )   }}</code></pre><p>以上实例运行结果：</p><pre><code>第一行 - a 不等于 b第二行 - a 不小于 b第三行 - a 大于 b第四行 - a 小于等于 b第五行 - b 大于等于 a</code></pre><h5 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h5><p>下表列出了所有Go语言的逻辑运算符。假定 A 值为 True，B 值为 False。<br>运算符    |描述|    实例<br>–|–|–<br>&amp;&amp;    |逻辑 AND 运算符。 如果两边的操作数都是 True，则条件 True，否则为 False。 |    (A &amp;&amp; B) 为 False<br>竖线竖线|    逻辑 OR 运算符。 如果两边的操作数有一个 True，则条件 True，否则为 False。|    (A 竖线竖线 B) 为 True<br>!|逻辑 NOT 运算符。 如果条件为 True，则逻辑 NOT 条件 False，否则为 True。|    !(A &amp;&amp; B) 为 True</p><p>以下实例演示了逻辑运算符的用法：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a bool = true   var b bool = false   if ( a &amp;&amp; b ) {      fmt.Printf(&quot;第一行 - 条件为 true\n&quot; )   }   if ( a || b ) {      fmt.Printf(&quot;第二行 - 条件为 true\n&quot; )   }   /* 修改 a 和 b 的值 */   a = false   b = true   if ( a &amp;&amp; b ) {      fmt.Printf(&quot;第三行 - 条件为 true\n&quot; )   } else {      fmt.Printf(&quot;第三行 - 条件为 false\n&quot; )   }   if ( !(a &amp;&amp; b) ) {      fmt.Printf(&quot;第四行 - 条件为 true\n&quot; )   }}</code></pre><p>以上实例运行结果：</p><pre><code>第二行 - 条件为 true第三行 - 条件为 false第四行 - 条件为 true</code></pre><h5 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h5><p>位运算符对整数在内存中的二进制位进行操作。</p><p>下表列出了位运算符 &amp;, |, 和 ^ 的计算：<br>p|    q|    p &amp; q|    p 竖 q|    p ^ q<br>–|–|–|–|–<br>0|    0|    0|    0|    0<br>0|    1|    0    |1|    1<br>1    |1|    1|    1|    0<br>1|    0|    0|    1|    1</p><p>假定 A = 60; B = 13; 其二进制数转换为：</p><pre><code>A = 0011 1100B = 0000 1101-----------------A&amp;B = 0000 1100A|B = 0011 1101A^B = 0011 0001</code></pre><p>Go 语言支持的位运算符如下表所示。假定 A 为60，B 为13：<br>运算符    |描述    |实例<br>–|–|–<br>&amp;    |按位与运算符”&amp;”是双目运算符。 其功能是参与运算的两数各对应的二进位相与。 |    (A &amp; B) 结果为 12, 二进制为 0000 1100<br>竖线|    按位或运算符”竖线”是双目运算符。 其功能是参与运算的两数各对应的二进位相或|    (A 竖线 B) 结果为 61, 二进制为 0011 1101<br>^|    按位异或运算符”^”是双目运算符。 其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。|    (A ^ B) 结果为 49, 二进制为 0011 0001<br>&lt;&lt;    |左移运算符”&lt;&lt;”是双目运算符。左移n位就是乘以2的n次方。 其功能把”&lt;&lt;”左边的运算数的各二进位全部左移若干位，由”&lt;&lt;”右边的数指定移动的位数，高位丢弃，低位补0。 |    A &lt;&lt; 2 结果为 240 ，二进制为 1111 0000</p><blockquote><blockquote><p>   |右移运算符”&gt;&gt;”是双目运算符。右移n位就是除以2的n次方。 其功能是把”&gt;&gt;”左边的运算数的各二进位全部右移若干位，”&gt;&gt;”右边的数指定移动的位数。|     A &gt;&gt; 2 结果为 15 ，二进制为 0000 1111</p></blockquote></blockquote><p>以下实例演示了位运算符的用法：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a uint = 60    /* 60 = 0011 1100 */     var b uint = 13    /* 13 = 0000 1101 */   var c uint = 0             c = a &amp; b       /* 12 = 0000 1100 */    fmt.Printf(&quot;第一行 - c 的值为 %d\n&quot;, c )   c = a | b       /* 61 = 0011 1101 */   fmt.Printf(&quot;第二行 - c 的值为 %d\n&quot;, c )   c = a ^ b       /* 49 = 0011 0001 */   fmt.Printf(&quot;第三行 - c 的值为 %d\n&quot;, c )   c = a &lt;&lt; 2     /* 240 = 1111 0000 */   fmt.Printf(&quot;第四行 - c 的值为 %d\n&quot;, c )   c = a &gt;&gt; 2     /* 15 = 0000 1111 */   fmt.Printf(&quot;第五行 - c 的值为 %d\n&quot;, c )}</code></pre><p>以上实例运行结果：</p><pre><code>第一行 - c 的值为 12第二行 - c 的值为 61第三行 - c 的值为 49第四行 - c 的值为 240第五行 - c 的值为 15</code></pre><h5 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h5><p>下表列出了所有Go语言的赋值运算符。<br>运算符|    描述|实例<br>–|–|–<br>=    |简单的赋值运算符，将一个表达式的值赋给一个左值|    C = A + B 将 A + B 表达式结果赋值给 C<br>+=    |相加后再赋值|    C += A 等于 C = C + A<br>-=    |相减后再赋值|    C -= A 等于 C = C - A<br>*=    |相乘后再赋值|    C *= A 等于 C = C * A<br>/=    |相除后再赋值|    C /= A 等于 C = C / A<br>%=    |求余后再赋值|    C %= A 等于 C = C % A<br>&lt;&lt;=    |左移后赋值 |    C &lt;&lt;= 2 等于 C = C &lt;&lt; 2</p><blockquote><blockquote><p>=    |右移后赋值 |    C &gt;&gt;= 2 等于 C = C &gt;&gt; 2<br>&amp;=    |按位与后赋值|    C &amp;= 2 等于 C = C &amp; 2<br>^=    |按位异或后赋值    |C ^= 2 等于 C = C ^ 2<br>竖线=|    按位或后赋值|    C 竖线= 2 等于 C = C | 2</p></blockquote></blockquote><p>以下实例演示了赋值运算符的用法：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a int = 21   var c int   c =  a   fmt.Printf(&quot;第 1 行 - =  运算符实例，c 值为 = %d\n&quot;, c )   c +=  a   fmt.Printf(&quot;第 2 行 - += 运算符实例，c 值为 = %d\n&quot;, c )   c -=  a   fmt.Printf(&quot;第 3 行 - -= 运算符实例，c 值为 = %d\n&quot;, c )   c *=  a   fmt.Printf(&quot;第 4 行 - *= 运算符实例，c 值为 = %d\n&quot;, c )   c /=  a   fmt.Printf(&quot;第 5 行 - /= 运算符实例，c 值为 = %d\n&quot;, c )   c  = 200;    c &lt;&lt;=  2   fmt.Printf(&quot;第 6行  - &lt;&lt;= 运算符实例，c 值为 = %d\n&quot;, c )   c &gt;&gt;=  2   fmt.Printf(&quot;第 7 行 - &gt;&gt;= 运算符实例，c 值为 = %d\n&quot;, c )   c &amp;=  2   fmt.Printf(&quot;第 8 行 - &amp;= 运算符实例，c 值为 = %d\n&quot;, c )   c ^=  2   fmt.Printf(&quot;第 9 行 - ^= 运算符实例，c 值为 = %d\n&quot;, c )   c |=  2   fmt.Printf(&quot;第 10 行 - |= 运算符实例，c 值为 = %d\n&quot;, c )}</code></pre><p>以上实例运行结果：</p><pre><code>第 1 行 - =  运算符实例，c 值为 = 21第 2 行 - += 运算符实例，c 值为 = 42第 3 行 - -= 运算符实例，c 值为 = 21第 4 行 - *= 运算符实例，c 值为 = 441第 5 行 - /= 运算符实例，c 值为 = 21第 6行  - &lt;&lt;= 运算符实例，c 值为 = 800第 7 行 - &gt;&gt;= 运算符实例，c 值为 = 200第 8 行 - &amp;= 运算符实例，c 值为 = 0第 9 行 - ^= 运算符实例，c 值为 = 2第 10 行 - |= 运算符实例，c 值为 = 2</code></pre><h5 id="其他运算符"><a href="#其他运算符" class="headerlink" title="其他运算符"></a>其他运算符</h5><p>下表列出了Go语言的其他运算符。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>返回变量存储地址</td><td>&a; 将给出变量的实际地址。</td></tr><tr><td>*</td><td>指针变量。</td><td>*a; 是一个指针变量</td></tr></tbody></table><p>以下实例演示了其他运算符的用法：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a int = 4   var b int32   var c float32   var ptr *int   /* 运算符实例 */   fmt.Printf(&quot;第 1 行 - a 变量类型为 = %T\n&quot;, a );   fmt.Printf(&quot;第 2 行 - b 变量类型为 = %T\n&quot;, b );   fmt.Printf(&quot;第 3 行 - c 变量类型为 = %T\n&quot;, c );   /*  &amp; 和 * 运算符实例 */   ptr = &amp;a    /* &#39;ptr&#39; 包含了 &#39;a&#39; 变量的地址 */   fmt.Printf(&quot;a 的值为  %d\n&quot;, a);   fmt.Printf(&quot;*ptr 为 %d\n&quot;, *ptr);}</code></pre><p>以上实例运行结果：</p><pre><code>第 1 行 - a 变量类型为 = int第 2 行 - b 变量类型为 = int32第 3 行 - c 变量类型为 = float32a 的值为  4*ptr 为 4</code></pre><h5 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h5><p>有些运算符拥有较高的优先级，二元运算符的运算方向均是从左至右。下表列出了所有运算符以及它们的优先级，由上至下代表优先级由高到低：</p><table><thead><tr><th>优先级</th><th>运算符</th></tr></thead><tbody><tr><td>7</td><td>^ !</td></tr><tr><td>6</td><td>* / % &lt;&lt; &gt;&gt; &amp; &amp;^</td></tr><tr><td>5</td><td>+ - 竖线 ^</td></tr><tr><td>4</td><td>== != &lt; &lt;= &gt;= &gt;</td></tr><tr><td>3</td><td>&lt;-</td></tr><tr><td>2</td><td>&amp;&amp;</td></tr><tr><td>1</td><td>竖线竖线</td></tr></tbody></table><p>当然，你可以通过使用括号来临时提升某个表达式的整体运算优先级。</p><p>以上实例运行结果：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a int = 20   var b int = 10   var c int = 15   var d int = 5   var e int;   e = (a + b) * c / d;      // ( 30 * 15 ) / 5   fmt.Printf(&quot;(a + b) * c / d 的值为 : %d\n&quot;,  e );   e = ((a + b) * c) / d;    // (30 * 15 ) / 5   fmt.Printf(&quot;((a + b) * c) / d 的值为  : %d\n&quot; ,  e );   e = (a + b) * (c / d);   // (30) * (15/5)   fmt.Printf(&quot;(a + b) * (c / d) 的值为  : %d\n&quot;,  e );   e = a + (b * c) / d;     //  20 + (150/5)   fmt.Printf(&quot;a + (b * c) / d 的值为  : %d\n&quot; ,  e );  }</code></pre><p>以上实例运行结果：</p><pre><code>(a + b) * c / d 的值为 : 90((a + b) * c) / d 的值为  : 90(a + b) * (c / d) 的值为  : 90a + (b * c) / d 的值为  : 50</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (六)：常量</title>
      <link href="/posts/70d70332/"/>
      <url>/posts/70d70332/</url>
      
        <content type="html"><![CDATA[<p>常量是一个简单值的标识符，在程序运行时，不会被修改的量。</p><p>常量中的数据类型只可以是布尔型、数字型（整数型、浮点型和复数）和字符串型。</p><p>常量的定义格式：</p><pre><code>const identifier [type] = value</code></pre><p>你可以省略类型说明符 [type]，因为编译器可以根据变量的值来推断其类型。</p><ul><li>显式类型定义： const b string = “abc”</li><li>隐式类型定义： const b = “abc”</li></ul><p>多个相同类型的声明可以简写为：</p><pre><code>const c_name1, c_name2 = value1, value2</code></pre><p>以下实例演示了常量的应用：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   const LENGTH int = 10   const WIDTH int = 5      var area int   const a, b, c = 1, false, &quot;str&quot; //多重赋值   area = LENGTH * WIDTH   fmt.Printf(&quot;面积为 : %d&quot;, area)   println()   println(a, b, c)   }</code></pre><p>以上实例运行结果为：</p><pre><code>面积为 : 501 false str</code></pre><p>常量还可以用作枚举：</p><pre><code>const (    Unknown = 0    Female = 1    Male = 2)</code></pre><p>数字 0、1 和 2 分别代表未知性别、女性和男性。</p><p>常量可以用len(), cap(), unsafe.Sizeof()函数计算表达式的值。常量表达式中，函数必须是内置函数，否则编译不过：</p><pre><code>package mainimport &quot;unsafe&quot;const (    a = &quot;abc&quot;    b = len(a)    c = unsafe.Sizeof(a))func main(){    println(a, b, c)}</code></pre><p>以上实例运行结果为：</p><pre><code>abc 3 16</code></pre><h3 id="iota"><a href="#iota" class="headerlink" title="iota"></a>iota</h3><p>iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p><p>iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p><p>iota 可以被用作枚举值：</p><pre><code>const (    a = iota    b = iota    c = iota)</code></pre><p>第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1；所以 a=0, b=1, c=2 可以简写为如下形式：</p><pre><code>const (    a = iota    b    c)</code></pre><p>iota 用法</p><pre><code>package mainimport &quot;fmt&quot;func main() {    const (            a = iota   //0            b          //1            c          //2            d = &quot;ha&quot;   //独立值，iota += 1            e          //&quot;ha&quot;   iota += 1            f = 100    //iota +=1            g          //100  iota +=1            h = iota   //7,恢复计数            i          //8    )    fmt.Println(a,b,c,d,e,f,g,h,i)}</code></pre><p>以上实例运行结果为：</p><pre><code>0 1 2 ha ha 100 100 7 8</code></pre><p>再看个有趣的的 iota 实例：</p><pre><code>package mainimport &quot;fmt&quot;const (    i=1&lt;&lt;iota    j=3&lt;&lt;iota    k    l)func main() {    fmt.Println(&quot;i=&quot;,i)    fmt.Println(&quot;j=&quot;,j)    fmt.Println(&quot;k=&quot;,k)    fmt.Println(&quot;l=&quot;,l)}</code></pre><p>以上实例运行结果为：</p><pre><code>i= 1j= 6k= 12l= 24</code></pre><p>iota 表示从 0 开始自动加 1，所以 i=1&lt;&lt;0, j=3&lt;&lt;1（&lt;&lt; 表示左移的意思），即：i=1, j=6，这没问题，关键在 k 和 l，从输出结果看 k=3&lt;&lt;2，l=3&lt;&lt;3。</p><p>简单表述:</p><ul><li>i=1：左移 0 位,不变仍为 1;</li><li>j=3：左移 1 位,变为二进制 110, 即 6;</li><li>k=3：左移 2 位,变为二进制 1100, 即 12;</li><li>l=3：左移 3 位,变为二进制 11000,即 24。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (五)：变量</title>
      <link href="/posts/2be8cdf3/"/>
      <url>/posts/2be8cdf3/</url>
      
        <content type="html"><![CDATA[<p>变量来源于数学，是计算机语言中能储存计算结果或能表示值抽象概念。变量可以通过变量名访问。</p><p>Go 语言变量名由字母、数字、下划线组成，其中首个字母不能为数字。</p><p>声明变量的一般形式是使用 var 关键字：</p><pre><code>var identifier type</code></pre><h5 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h5><p>第一种，指定变量类型，声明后若不赋值，使用默认值。</p><pre><code>var v_name v_typev_name = value</code></pre><p>第二种，根据值自行判定变量类型。</p><pre><code>var v_name = value</code></pre><p>第三种，省略var, 注意 :=左侧的变量不应该是已经声明过的，否则会导致编译错误。</p><pre><code>v_name := value// 例如var a int = 10var b = 10c := 10</code></pre><p>实例如下：</p><pre><code>package mainvar a = &quot;天才白痴梦&quot;var b string = &quot;tcbcm.cn&quot;var c boolfunc main(){    println(a, b, c)}</code></pre><p>以上实例执行结果为：</p><pre><code>天才白痴梦 tcbcm.cn false</code></pre><h5 id="多变量声明"><a href="#多变量声明" class="headerlink" title="多变量声明"></a>多变量声明</h5><pre><code>//类型相同多个变量, 非全局变量var vname1, vname2, vname3 typevname1, vname2, vname3 = v1, v2, v3var vname1, vname2, vname3 = v1, v2, v3 //和python很像,不需要显示声明类型，自动推断vname1, vname2, vname3 := v1, v2, v3 //出现在:=左侧的变量不应该是已经被声明过的，否则会导致编译错误// 这种因式分解关键字的写法一般用于声明全局变量var (    vname1 v_type1    vname2 v_type2)</code></pre><p>实例如下：</p><pre><code>package mainvar x, y intvar (  // 这种因式分解关键字的写法一般用于声明全局变量    a int    b bool)var c, d int = 1, 2var e, f = 123, &quot;hello&quot;//这种不带声明格式的只能在函数体中出现//g, h := 123, &quot;hello&quot;func main(){    g, h := 123, &quot;hello&quot;    println(x, y, a, b, c, d, e, f, g, h)}</code></pre><p>以上实例执行结果为：</p><pre><code>0 0 0 false 1 2 123 hello 123 hello</code></pre><h5 id="值类型和引用类型"><a href="#值类型和引用类型" class="headerlink" title="值类型和引用类型"></a>值类型和引用类型</h5><p>所有像 int、float、bool 和 string 这些基本类型都属于值类型，使用这些类型的变量直接指向存在内存中的值：</p><pre><code>4.4.2_fig4.1</code></pre><p>当使用等号 = 将一个变量的值赋值给另一个变量时，如：j = i，实际上是在内存中将 i 的值进行了拷贝：</p><pre><code>4.4.2_fig4.2</code></pre><p>你可以通过 &amp;i 来获取变量 i 的内存地址，例如：0xf840000040（每次的地址都可能不一样）。值类型的变量的值存储在栈中。</p><p>内存地址会根据机器的不同而有所不同，甚至相同的程序在不同的机器上执行后也会有不同的内存地址。因为每台机器可能有不同的存储器布局，并且位置分配也可能不同。</p><p>更复杂的数据通常会需要使用多个字，这些数据一般使用引用类型保存。</p><p>一个引用类型的变量 r1 存储的是 r1 的值所在的内存地址（数字），或内存地址中第一个字所在的位置。</p><pre><code>4.4.2_fig4.3</code></pre><p>这个内存地址为称之为指针，这个指针实际上也被存在另外的某一个字中。</p><p>同一个引用类型的指针指向的多个字可以是在连续的内存地址中（内存布局是连续的），这也是计算效率最高的一种存储形式；也可以将这些字分散存放在内存中，每个字都指示了下一个字所在的内存地址。</p><p>当使用赋值语句 r2 = r1 时，只有引用（地址）被复制。</p><p>如果 r1 的值被改变了，那么这个值的所有引用都会指向被修改后的内容，在这个例子中，r2 也会受到影响。</p><h5 id="简短形式，使用-赋值操作符"><a href="#简短形式，使用-赋值操作符" class="headerlink" title="简短形式，使用 := 赋值操作符"></a>简短形式，使用 := 赋值操作符</h5><p>我们知道可以在变量的初始化时省略变量的类型而由系统自动推断，声明语句写上 var 关键字其实是显得有些多余了，因此我们可以将它们简写为 a := 50 或 b := false。</p><p>a 和 b 的类型（int 和 bool）将由编译器自动推断。</p><p>这是使用变量的首选形式，但是它只能被用在函数体内，而不可以用于全局变量的声明与赋值。使用操作符 := 可以高效地创建一个新的变量，称之为初始化声明。</p><h6 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h6><p>如果在相同的代码块中，我们不可以再次对于相同名称的变量使用初始化声明，例如：a := 20 就是不被允许的，编译器会提示错误 no new variables on left side of :=，但是 a = 20 是可以的，因为这是给相同的变量赋予一个新的值。</p><p>如果你在定义变量 a 之前使用它，则会得到编译错误 undefined: a。</p><p>如果你声明了一个局部变量却没有在相同的代码块中使用它，同样会得到编译错误，例如下面这个例子当中的变量 a：</p><pre><code>package mainimport &quot;fmt&quot;func main() {   var a string = &quot;abc&quot;   fmt.Println(&quot;hello, world&quot;)}</code></pre><p>尝试编译这段代码将得到错误 a declared and not used。</p><p>此外，单纯地给 a 赋值也是不够的，这个值必须被使用，所以使用</p><pre><code>fmt.Println(&quot;hello, world&quot;, a)</code></pre><p>会移除错误。</p><p>但是全局变量是允许声明但不使用。 同一类型的多个变量可以声明在同一行，如：</p><pre><code>var a, b, c int</code></pre><p>多变量可以在同一行进行赋值，如：</p><pre><code>var a, b intvar c stringa, b, c = 5, 7, &quot;abc&quot;</code></pre><p>上面这行假设了变量 a，b 和 c 都已经被声明，否则的话应该这样使用：</p><pre><code>a, b, c := 5, 7, &quot;abc&quot;</code></pre><p>右边的这些值以相同的顺序赋值给左边的变量，所以 a 的值是 5， b 的值是 7，c 的值是 “abc”。</p><p>这被称为 并行 或 同时 赋值。</p><p>如果你想要交换两个变量的值，则可以简单地使用 a, b = b, a，两个变量的类型必须是相同。</p><p>空白标识符 _ 也被用于抛弃值，如值 5 在：_, b = 5, 7 中被抛弃。</p><p>_ 实际上是一个只写变量，你不能得到它的值。这样做是因为 Go 语言中你必须使用所有被声明的变量，但有时你并不需要使用从一个函数得到的所有返回值。</p><p>并行赋值也被用于当一个函数返回多个返回值时，比如这里的 val 和错误 err 是通过调用 Func1 函数同时得到：val, err = Func1(var1)。 </p>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (四)：数据类型</title>
      <link href="/posts/210c5b2c/"/>
      <url>/posts/210c5b2c/</url>
      
        <content type="html"><![CDATA[<p>在 Go 编程语言中，数据类型用于声明函数和变量。</p><p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><h5 id="Go-语言按类别有以下几种数据类型："><a href="#Go-语言按类别有以下几种数据类型：" class="headerlink" title="Go 语言按类别有以下几种数据类型："></a>Go 语言按类别有以下几种数据类型：</h5><table><thead><tr><th>序号</th><th>类型和描述</th></tr></thead><tbody><tr><td>1</td><td>布尔型:布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。</td></tr><tr><td>2</td><td>数字类型:整型 int 和浮点型 float，Go 语言支持整型和浮点型数字，并且原生支持复数，其中位的运算采用补码。</td></tr><tr><td>3</td><td>字符串类型:字符串就是一串固定长度的字符连接起来的字符序列。Go的字符串是由单个字节连接起来的。Go语言的字符串的字节使用UTF-8编码标识Unicode文本。</td></tr><tr><td>4</td><td>派生类型:包括：(a) 指针类型（Pointer）;(b) 数组类型;(c) 结构化类型(struct);(d) Channel 类型;(e) 函数类型;(f) 切片类型;(g) 接口类型（interface）;(h) Map 类型</td></tr></tbody></table><h5 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h5><p>Go 也有基于架构的类型，例如：int、uint 和 uintptr。<br>序号 |    类型和描述<br>—|—<br>1 |    uint8:无符号 8 位整型 (0 到 255)<br>2 |    uint16:无符号 16 位整型 (0 到 65535)<br>3 |    uint32:无符号 32 位整型 (0 到 4294967295)<br>4 |    uint64:无符号 64 位整型 (0 到 18446744073709551615)<br>5 |    int8:有符号 8 位整型 (-128 到 127)<br>6 |    int16:有符号 16 位整型 (-32768 到 32767)<br>7     |int32:有符号 32 位整型 (-2147483648 到 2147483647)<br>8 |    int64:有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)</p><h5 id="浮点型："><a href="#浮点型：" class="headerlink" title="浮点型："></a>浮点型：</h5><table><thead><tr><th>序号</th><th>类型和描述</th></tr></thead><tbody><tr><td>1</td><td>float32:IEEE-754 32位浮点型数</td></tr><tr><td>2</td><td>float64:IEEE-754 64位浮点型数</td></tr><tr><td>3</td><td>complex64:32 位实数和虚数</td></tr><tr><td>4</td><td>complex128:64 位实数和虚数</td></tr></tbody></table><h5 id="其他数字类型"><a href="#其他数字类型" class="headerlink" title="其他数字类型"></a>其他数字类型</h5><p>以下列出了其他更多的数字类型：<br>序号 |    类型和描述<br>—|—<br>1 |    byte：类似 uint8<br>2 |    rune：类似 int32<br>3 |    uint：32 或 64 位<br>4 |int：与 uint 一样大小<br>5 |    uintptr：无符号整型，用于存放一个指针</p>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (三)：基础语法</title>
      <link href="/posts/a5e7c61a/"/>
      <url>/posts/a5e7c61a/</url>
      
        <content type="html"><![CDATA[<p>上一章节我们已经了解了 Go 语言的基本组成结构，本章节我们将学习 Go 语言的基础语法。</p><h5 id="Go-标记"><a href="#Go-标记" class="headerlink" title="Go 标记"></a>Go 标记</h5><p>Go 程序可以由多个标记组成，可以是关键字，标识符，常量，字符串，符号。如以下 GO 语句由 6 个标记组成：</p><pre><code>fmt.Println(&quot;Hello, World!&quot;)</code></pre><p>6 个标记是(每行一个)：</p><pre><code>1. fmt2. .3. Println4. (5. &quot;Hello, World!&quot;6. )</code></pre><h6 id="行分隔符"><a href="#行分隔符" class="headerlink" title="行分隔符"></a>行分隔符</h6><p>在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。</p><p>如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。</p><p>以下为两个语句：</p><pre><code>fmt.Println(&quot;Hello,World!&quot;)fmt.Println(&quot;阿里云大学：edu.aliyun.com&quot;)</code></pre><h5 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h5><p>注释不会被编译，每一个包应该有相关注释。</p><p>单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾。如：</p><pre><code>// 单行注释/*    Author by 阿里云大学：edu.aliyun.com    我是多行注释*/</code></pre><h5 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h5><p>标识符用来命名变量、类型等程序实体。一个标识符实际上就是一个或是多个字母(A<del>Z和a</del>z)数字(0~9)、下划线_组成的序列，但是第一个字符必须是字母或下划线而不能是数字。</p><p>以下是有效的标识符：</p><pre><code>mahesh kumar abc move_name a_123myname50 _temp j a23b9 retVal</code></pre><p>以下是无效的标识符：</p><ul><li>1ab（以数字开头）</li><li>case（Go 语言的关键字）</li><li>a+b（运算符是不允许的）</li></ul><h5 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h5><p>下面列举了 Go 代码中会使用到的 25 个关键字或保留字：</p><table><thead><tr><th>break</th><th>default</th><th>func</th><th>interface</th><th>select</th></tr></thead><tbody><tr><td>case</td><td>defer</td><td>go</td><td>map</td><td>struct</td></tr><tr><td>chan</td><td>else</td><td>goto</td><td>package</td><td>switch</td></tr><tr><td>const</td><td>fallthrough</td><td>if</td><td>range</td><td>type</td></tr><tr><td>continue</td><td>for</td><td>import</td><td>return</td><td>var</td></tr></tbody></table><p>除了以上介绍的这些关键字，Go 语言还有 36 个预定义标识符：<br>append |    bool |    byte |    cap |    close |    complex |    complex64 |    complex128 |    uint16<br>—|—|—|—|—|—|—|—|—<br>copy |    false|     float32 |    float64 |    imag |    int |    int8 |    int16 |    uint32<br>int32 |    int64 |    iota |    len |    make |    new |    nil |    panic |    uint64<br>print |    println |    real |    recover |    string |    true |    uint |    uint8 |    uintptr</p><ul><li>程序一般由关键字、常量、变量、运算符、类型和函数组成。</li><li>程序中可能会使用到这些分隔符：括号 ()，中括号 [] 和大括号 {}。</li><li>程序中可能会使用到这些标点符号：.、,、;、: 和 …。</li></ul><h5 id="Go-语言的空格"><a href="#Go-语言的空格" class="headerlink" title="Go 语言的空格"></a>Go 语言的空格</h5><p>Go 语言中变量的声明必须使用空格隔开，如：</p><pre><code>var age int;</code></pre><p>语句中适当使用空格能让程序看易阅读。</p><p>无空格：</p><pre><code>fruit=apples+oranges;</code></pre><p>在变量与运算符间加入空格，程序看起来更加美观，如：</p><pre><code>fruit = apples + oranges;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (二)：结构</title>
      <link href="/posts/f63be79c/"/>
      <url>/posts/f63be79c/</url>
      
        <content type="html"><![CDATA[<p>在我们开始学习 Go 编程语言的基础构建模块前，让我们先来了解 Go 语言最简单程序的结构。</p><h5 id="Go-Hello-World-实例"><a href="#Go-Hello-World-实例" class="headerlink" title="Go Hello World 实例"></a>Go Hello World 实例</h5><p>Go 语言的基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><p>接下来让我们来看下简单的代码，该代码输出了”Hello World!”:</p><pre><code>  package main  import &quot;fmt&quot;  func main() {       /* 这是我的第一个简单的程序 */      fmt.Println(&quot;Hello, World!&quot;)  }</code></pre><p>让我们来看下以上程序的各个部分：</p><ol><li><p>第一行代码 package main定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</p></li><li><p>下一行 import “fmt” 。告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数。</p></li><li><p>下一行 func main() 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</p></li><li><p>下一行 /<em>…</em>/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。</p></li><li><p>下一行 fmt.Println(…) 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。<br>使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。<br>Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</p></li><li><p>当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected ）。</p></li></ol><h5 id="执行-Go-程序"><a href="#执行-Go-程序" class="headerlink" title="执行 Go 程序"></a>执行 Go 程序</h5><p>让我们来看下如何编写 Go 代码并执行它。步骤如下：</p><ol><li><p>打开编辑器如Sublime2，将以上代码添加到编辑器中。</p></li><li><p>将以上代码保存为 hello.go</p></li><li><p>打开命令行，并进入程序文件保存的目录中。</p></li><li><p>输入命令 go run hello.go 并按回车执行代码。</p></li><li><p>如果操作正确你将在屏幕上看到 “Hello World!”字样的输出。</p><pre><code> $ go run hello.go Hello, World!</code></pre></li></ol><h6 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h6><p>需要注意的是 { 不能单独放在一行，所以以下代码在运行时会产生错误：</p><pre><code>    package main    import &quot;fmt&quot;    func main()      {  // 错误，{ 不能在单独的行上        fmt.Println(&quot;Hello, World!&quot;)    }</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang (一)：基础知识</title>
      <link href="/posts/39c551f2/"/>
      <url>/posts/39c551f2/</url>
      
        <content type="html"><![CDATA[<p>Go 是一个开源的编程语言，它能让构造简单、可靠且高效的软件变得容易。</p><p>Go是从2007年末由Robert Griesemer, Rob Pike, Ken Thompson主持开发，后来还加入了Ian Lance Taylor, Russ Cox等人，并最终于2009年11月开源，在2012年早些时候发布了Go 1稳定版本。现在Go的开发已经是完全开放的，并且拥有一个活跃的社区。</p><h5 id="Go-语言特色"><a href="#Go-语言特色" class="headerlink" title="Go 语言特色"></a>Go 语言特色</h5><pre><code>简洁、快速、安全并行、有趣、开源内存管理、v数组安全、编译迅速</code></pre><h5 id="Go-语言用途"><a href="#Go-语言用途" class="headerlink" title="Go 语言用途"></a>Go 语言用途</h5><p>Go 语言被设计成一门应用于搭载 Web 服务器，存储集群或类似用途的巨型中央服务器的系统编程语言。</p><p>对于高性能分布式系统领域而言，Go 语言无疑比大多数其它语言有着更高的开发效率。它提供了海量并行的支持，这对于游戏服务端的开发而言是再好不过了。</p><h5 id="第一个-Go-程序"><a href="#第一个-Go-程序" class="headerlink" title="第一个 Go 程序"></a>第一个 Go 程序</h5><p>接下来我们来编写第一个 Go 程序 hello.go（Go 语言源文件的扩展是 .go），代码如下：<br>实例</p><pre><code>package mainimport &quot;fmt&quot;func main() {        fmt.Println(&quot;Hello, World!&quot;)}</code></pre><p>执行以上代码输出</p><pre><code>$ go run hello.goHello, World!</code></pre><h4 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h4><p>Go 语言支持以下系统：</p><pre><code>LinuxFreeBSDMac OS X（也称为 Darwin）Window</code></pre><p>安装包下载地址为：<a href="https://golang.org/dl/。" target="_blank" rel="noopener">https://golang.org/dl/。</a></p><p>如果打不开可以使用这个地址：<a href="https://golang.google.cn/dl/。" target="_blank" rel="noopener">https://golang.google.cn/dl/。</a></p><p>各个系统对应的包名：<br>操作系统 |    包名<br>—|—<br>Windows |    go1.4.windows-amd64.msi<br>Linux |    go1.4.linux-amd64.tar.gz<br>Mac |    go1.4.darwin-amd64-osx10.8.pkg<br>FreeBSD |    go1.4.freebsd-amd64.tar.gz</p><h5 id="UNIX-Linux-Mac-OS-X-和-FreeBSD-安装"><a href="#UNIX-Linux-Mac-OS-X-和-FreeBSD-安装" class="headerlink" title="UNIX/Linux/Mac OS X, 和 FreeBSD 安装"></a>UNIX/Linux/Mac OS X, 和 FreeBSD 安装</h5><p>以下介绍了在UNIX/Linux/Mac OS X, 和 FreeBSD系统下使用源码安装方法：</p><p>1、下载源码包：go1.4.linux-amd64.tar.gz。</p><p>2、将下载的源码包解压至 /usr/local目录。</p><pre><code>       tar -C /usr/local -xzf go1.4.linux-amd64.tar.gz</code></pre><p>3、将 /usr/local/go/bin 目录添加至PATH环境变量：</p><pre><code>      export PATH=$PATH:/usr/local/go/bin</code></pre><p>注意：MAC 系统下你可以使用 .pkg 结尾的安装包直接双击来完成安装，安装目录在 /usr/local/go/ 下。</p><h5 id="Windows-系统下安装"><a href="#Windows-系统下安装" class="headerlink" title="Windows 系统下安装"></a>Windows 系统下安装</h5><p>Windows 下可以使用 .msi 后缀(在下载列表中可以找到该文件，如go1.4.2.windows-amd64.msi)的安装包来安装。</p><p>默认情况下.msi文件会安装在 c:\Go 目录下。你可以将 c:\Go\bin 目录添加到 PATH 环境变量中。添加后你需要重启命令窗口才能生效。</p><h6 id="安装测试"><a href="#安装测试" class="headerlink" title="安装测试"></a>安装测试</h6><p>创建工作目录 C:&gt;Go_WorkSpace。</p><p>文件名: test.go，代码如下：</p><pre><code> package main import &quot;fmt&quot; func main() {         fmt.Println(&quot;Hello, World!&quot;) }</code></pre><p>使用 go 命令执行以上代码输出结果如下：</p><pre><code>C:\Go_WorkSpace&gt;go run test.goHello, World!</code></pre>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2018年，新的一年，努力工作，快乐生活。</title>
      <link href="/posts/8f3dfe1b/"/>
      <url>/posts/8f3dfe1b/</url>
      
        <content type="html"><![CDATA[<p>2018年，新的一年，努力工作，快乐生活。</p><p>曾经读过杨石头老师的书，里面有这样一段：从个人奋斗的节点上看，你我真正的有效奋斗时间段也就30年，分别是20～30岁，30～40岁，40～50岁。</p><h4 id="20岁靠的是努力。"><a href="#20岁靠的是努力。" class="headerlink" title="20岁靠的是努力。"></a>20岁靠的是努力。</h4><p>重点是学习如何成为一员有专业素养的精兵，找到立身之本的根。这个阶段的困难在于，你要在最耐不住寂寞的年纪做耐得住寂寞的事。或许你会觉得，在这个阶段很多的努力看上去是无果且无望的。但你记住，不要懈怠，不要放弃，坚持努力下去。只有傻X一样地坚持，才会有牛X一样的结果。</p><h4 id="30岁靠的是实力。"><a href="#30岁靠的是实力。" class="headerlink" title="30岁靠的是实力。"></a>30岁靠的是实力。</h4><p>重点是学习如何成为一名有管理能力的猛将，生长出持续发展的主干。这个阶段的你，如果投放到人才市场，既要有卖点，还要有卖相。而这些卖点和卖相，就是你实力的凝结。这个阶段你所要做的，是把专业深度、人格成熟度、人情练达度拧成自己的综合实力。</p><h4 id="40岁靠的是资历。"><a href="#40岁靠的是资历。" class="headerlink" title="40岁靠的是资历。"></a>40岁靠的是资历。</h4><p>重点是学习如何成为一位有经营水平的明帅，建设枝繁叶茂的系统。在这个阶段，你的经验、资格、见识、荣誉都需要上得了台面。尽管我并不主张看重身份，但这个社会的确是通过身份与资历来确定你是谁。你有多少话语权，别人首先会看你在哪儿混过，其次会看你跟什么样的人在一起混，从而判断你是边角料型人才，还是能把控一方的支柱型人才。</p><h4 id="50岁靠的是势力。"><a href="#50岁靠的是势力。" class="headerlink" title="50岁靠的是势力。"></a>50岁靠的是势力。</h4><p>重点是学习如何成为一位成就组织的王者，培育众木成林的势力生态。桃李满天下，知交遍天涯，哪里都有你的关系网。成为培育组织、保护组织、成长组织的人物。</p><p>我理解的成功生涯规划，就是在你二十几岁的时候，给优秀的人工作；在三十几岁时跟优秀的人合作；在四十几岁时找优秀的人为你工作；而到了五十几岁时，努力使别人成为更加优秀的人。</p><p>当然，你可以加快自我修炼的速度，用进步推动进化。或许你在35岁就已经就是明帅了，或许你在40岁就懂得内圣而外王之道了，这都是有可能的。你也可以说，干嘛要这么在乎时间点，生命不息奋斗就不止啊！不过从现实的角度看，50岁以后，你真正能依靠的都是前面铺设好的轨道与建好的机车，而不是天上掉馅饼的奇迹。</p><h3 id="社会这个无情货是如何看待你的价值阶段的呢？"><a href="#社会这个无情货是如何看待你的价值阶段的呢？" class="headerlink" title="社会这个无情货是如何看待你的价值阶段的呢？"></a>社会这个无情货是如何看待你的价值阶段的呢？</h3><h4 id="20岁看重的是你可不可教。"><a href="#20岁看重的是你可不可教。" class="headerlink" title="20岁看重的是你可不可教。"></a>20岁看重的是你可不可教。</h4><p>不是每个人都是可造之材，有些人还真就是朽木。摆出一副拒绝教化，爱谁谁的德性，请放心，这种情况下没人上杆子教化你。如果你不是朽木，那你就得让自己看上去有“孺子可教”的精进范儿和谦逊范儿，要学会用低姿态润滑周边环境，从而最大化地吸纳前辈的指教。</p><h4 id="30岁看重的是你可不可用。"><a href="#30岁看重的是你可不可用。" class="headerlink" title="30岁看重的是你可不可用。"></a>30岁看重的是你可不可用。</h4><p>你是不是有可用的专业价值？你是不是能够在某个局部担起重任？这时候的你首先要真有料，在某个领域有专业发言权，在整体的价值链条中，你是不可或缺的。</p><h4 id="40岁看重的是你可不可捧。"><a href="#40岁看重的是你可不可捧。" class="headerlink" title="40岁看重的是你可不可捧。"></a>40岁看重的是你可不可捧。</h4><p>到这个时候你要么往上发展成为一个管理经营人物，要么就往下滑沦为一个人手。这时候你要想收获里子面子，就看你是不是够格让大家捧你，拿肩膀出来给你垫。</p><h4 id="50岁看重的是你可不可敬。"><a href="#50岁看重的是你可不可敬。" class="headerlink" title="50岁看重的是你可不可敬。"></a>50岁看重的是你可不可敬。</h4><p>你的人格是否有厚度与深度，是否有成就组织的功力？让大家敬佩的人很多，但让人敬重的却很少，这是因为人格的内在力量不同。而这个时候，最大的破产就是人格破产。</p><p>人生到这个阶段，成功绝非只是功成名就，而更应该被解释为“成就功德”。有一天你回顾起来，在整个旅程中你做了哪些令自己骄傲的事？对别人，对行业，对社会的价值在哪里？成功不是财富的总和，更应该是为一个伟大梦想所进行的全程奋斗与表演。</p><p>而在人生大计划的赛场上，有一个上下半场的时间节点。总体说来，35岁以前是人生上半场，关键词是“不犹豫”。35岁开始是人生下半场，关键词是“不后悔”。</p><h3 id="工作之余，最应该关注的三件事！"><a href="#工作之余，最应该关注的三件事！" class="headerlink" title="工作之余，最应该关注的三件事！"></a>工作之余，最应该关注的三件事！</h3><h4 id="1、健康问题"><a href="#1、健康问题" class="headerlink" title="1、健康问题"></a>1、健康问题</h4><p>保持健康的重要性毋庸置疑，当属第一位。保持健康办法：劳逸结合、每天锻炼、注意睡眠时间、注意饮食、定期体检。说起来容易，做起来不容易，每个人都要不断提醒自己保持健康。</p><h4 id="2、核心竞争力"><a href="#2、核心竞争力" class="headerlink" title="2、核心竞争力"></a>2、核心竞争力</h4><p>坚持学习，保持自己的核心竞争力。坚持学习，并不是一定要一直学习编程知识，随着年龄增长，每个人可能选择不同的转型方向，热爱技术的会一直坚持编程学习，有的则转管理。选择方向也是好多种.<br>但是不管怎么样选择，一定要坚持学习，不要把工作之余大笔时间一直花费在游戏娱乐方面。保持自己的核心竞争力，才不至于被淘汰。</p><h4 id="3、被动收入"><a href="#3、被动收入" class="headerlink" title="3、被动收入"></a>3、被动收入</h4><p>被动收入指的是当你没劳动没工作的时候，仍然有收入。比如你开发了一款商业软件（或者付费APP），持续有人购买；比如你写了一本畅销书，不断有人买；比如你建了一个网站，请编辑更新内容后每天都有利润；比如你当了老板，离开了你，公司照样可以赚钱。<br>其它被动收入，可能包含一些投资或者已有资产（存款），比如你有几套房在出租，比如你大笔存款利息收入。</p><p>工作一段时间后，大家应该考虑一下有什么办法实现被动收入。同样是收入100万，工作工资100万  VS. 工作工资50万+其它被动收入50万 ，自然是有被动收入的来得稳当一些。</p><p>新的一年，新的起点。幸福都是奋斗出来的。必须不驰于空想、不骛于虚声，一步一个脚印，踏踏实实干好工作。</p>]]></content>
      
      
      <categories>
          
          <category> 悦读时光 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>JavaCC详解 SQL解析器</title>
      <link href="/posts/fd4b9af6/"/>
      <url>/posts/fd4b9af6/</url>
      
        <content type="html"><![CDATA[<h3 id="javacc概述"><a href="#javacc概述" class="headerlink" title="javacc概述"></a>javacc概述</h3><hr><p>JavaCC 是一个词法分析生成器和语法分析生成器。 词法分析和语法分析是处理输入字符序列的软件构件， 编译器和解释器协同词法分析和语法分析来“解密” 程序文件。</p><p>–<br>javacc的获取：<a href="https://java.net/projects/javacc/downloads从此处下载了javacc" target="_blank" rel="noopener">https://java.net/projects/javacc/downloads从此处下载了javacc</a> 5.0 然后解压并在path环境变量中添加 解压后的bin目录即可。</p><p>词法分析器可以将字符串解析为一个一<br>个的标识符(Token)， 并且可以把这些标识符归类。 看一段 C 语言代码：　　</p><pre><code>int main() {    return 0 ;}</code></pre><p>经过C语言的词法分析会将代码分为如下的一些标识符</p><pre><code>“int” , “ ” , “main” , “(” , “ )” ,“ ” , “{” , “ \n” ,“ \t” ,“return” “ ” , “0” , “ ” , “;” , “ \n” ,“ }” , “ \n” , “ ” </code></pre><p>还会进行分类，C语言的词法分析器会将其分为如下：</p><pre><code>KWINT, SPACE, ID, OPAR, CPAR,SPACE, OBRACE, SPACE, SPACE, KWRETURN,SPACE, OCTALCONST, SPACE, SEMICOLON, SPACE,CBRACE, SPACE, EOF。</code></pre><p>EOF代表文件的结束。经过词法分析，将这些标识符传给语法分析器。在C语言中 SPACE(空格) 是不需要的。<br>语法分析器将生成语法树：</p><p><img src="/img/javacc1.png" alt="img"></p><h2 id="javacc的特性"><a href="#javacc的特性" class="headerlink" title="javacc的特性"></a>javacc的特性</h2><p>使用递归下降语法解析，LL(k)。其中，第一个L表示从左到右扫描输入；第二个L表示每次都进行最左推导(在推导语法树的过程中每次都替换句型中最左的非终结符为终结符。类似还有最右推导)；k表示的是每次向前探索(lookahead)k个终结符</p><p>词法规则，语法规则定义在同一文件中，就是.jj文件。</p><p>jjTree可以帮助更好的语法分析(因为好像没用过，不好说啊)</p><p>可定制生成的行为，如对字母的大小写是否敏感。不如设计数据库sql语句的时候应该使用关键字大小写不敏感。</p><p>更向前一步解决移进规约。当文法本身存在二义性的时候有时候通过设置lookahead为k能解决问题，带来的问题就是增加编译时间，所以最好的方法是修改二义性文法为无二义性文法。</p><p>–<br>执行的流程如下图所示：</p><h2 id><a href="#" class="headerlink" title></a><img src="/img/javacc2.png" alt="img"></h2><h2 id="javacc生成的类"><a href="#javacc生成的类" class="headerlink" title="javacc生成的类"></a>javacc生成的类</h2><p>通过执行javacc Adder.jj命令以后（如果没有错误的话）生成了这个的七个java文件。</p><p><img src="/img/javacc3.png" alt="img"></p><p>他们是：</p><h3 id="TokenMgrError："><a href="#TokenMgrError：" class="headerlink" title="TokenMgrError："></a>TokenMgrError：</h3><p>简单的错误类，词法错误，实现了Throwable接口。</p><h3 id="Token-类："><a href="#Token-类：" class="headerlink" title="Token 类："></a>Token 类：</h3><p>单词定义处；每个单词至少由一个int型的kind变量来标识单词的”ID” 和一个String类型的image变量来标识单词的具体内容。</p><p><img src="/img/javacc4.png" alt="img"></p><h3 id="ParseException："><a href="#ParseException：" class="headerlink" title="ParseException："></a>ParseException：</h3><p>语法异常类，实现Exception接口，通常出现这种情况就是解析器罢工了。</p><h3 id="SimpleCharStream："><a href="#SimpleCharStream：" class="headerlink" title="SimpleCharStream："></a>SimpleCharStream：</h3><p>辅助类，用于输入字符串。可以接受InputStream类型和Reader类型的输入流。</p><p><img src="/img/javacc5.png" alt="img"></p><h3 id="AdderTokenManager："><a href="#AdderTokenManager：" class="headerlink" title="AdderTokenManager："></a>AdderTokenManager：</h3><p>Adder的词法分析器。<br>词法分析器有三个重要成员变量和方法：</p><p><img src="/img/javacc6.png" alt="img"></p><h3 id="AdderConstants："><a href="#AdderConstants：" class="headerlink" title="AdderConstants："></a>AdderConstants：</h3><p>含常量的辅助性接口。</p><p><img src="/img/javacc7.png" alt="img"></p><hr><h3 id="Adder："><a href="#Adder：" class="headerlink" title="Adder："></a>Adder：</h3><p>语法分析器。其中Adder中的方法来源于三个地方</p><p>写在PARSER_BEGIN和PARSER_END中的部分，即类声明部分的方法</p><p>写在语法结构部分的方法。<br>写在JavaCC中的方法。</p><h4 id="贴出Adder-jj的代码"><a href="#贴出Adder-jj的代码" class="headerlink" title="贴出Adder.jj的代码"></a>贴出Adder.jj的代码</h4><pre><code>PARSER_BEGIN(Adder)public class Adder{    public static void main(String[] args)  throws ParseException, TokenMgrError{        Adder adder= new Adder(System.in);        System.out.println(adder.start());    }}PARSER_END(Adder)SKIP:{    &quot; &quot;     | &quot;\t&quot;    | &quot;\n&quot;    | &quot;\r&quot;    | &quot;\r\n&quot;}TOKEN:{    |}int start() throws NumberFormatException:{    Token a;    int i;    int value;}{    value=primary()    (        i=primary()        {value += i;}        )*    {return value;}}int primary() throws NumberFormatException:{    Token t;}{    t=    {return Integer.parseInt(t.image);}}</code></pre><p>则在Adder.java中则存在这样的几个函数：<br><img src="/img/javacc8.png" alt="img"></p><p>–</p><h3 id="如何组织-jj文件"><a href="#如何组织-jj文件" class="headerlink" title="如何组织.jj文件"></a>如何组织.jj文件</h3><p>如何写javacc语法文件，将在未来的另外博客中体现，这个部分是实现的过程中最重要的部分了。</p><p>主要有4个方面需要注意</p><p>语法分析器的属性设置</p><p>语法分析器的类声明</p><p>词法规则声明</p><p>语法规则实现</p><h3 id="语法分析器的属性设置"><a href="#语法分析器的属性设置" class="headerlink" title="语法分析器的属性设置"></a>语法分析器的属性设置</h3><pre><code>options{    JDK_VERSION=1.5; //jdk版本    LOOKAHEAD=1;//LL(1)文法    static=true;//语法分析器是否为静态}</code></pre><p>关于这个option有很多内容可以讲</p><p>–</p><h3 id="语法分析器的类声明"><a href="#语法分析器的类声明" class="headerlink" title="语法分析器的类声明"></a>语法分析器的类声明</h3><pre><code>PARSER_BEGIN(Adder)public class Adder{    public static void main(String[] args)  throws ParseException, TokenMgrError{        Adder adder= new Adder(System.in);        System.out.println(adder.start());    }}PARSER_END(Adder)</code></pre><p>注意此处PARSER_BEGIN和PARSER_END应该与类声明一致即Adder</p><p>–</p><h3 id="词法规则声明"><a href="#词法规则声明" class="headerlink" title="词法规则声明"></a>词法规则声明</h3><pre><code>/*跳过的字符*/SKIP:{    &quot; &quot;     | &quot;\t&quot;    | &quot;\n&quot;    | &quot;\r&quot;    | &quot;\r\n&quot;}/*单词*/TOKEN:{    |}</code></pre><h3 id="语法规则实现"><a href="#语法规则实现" class="headerlink" title="语法规则实现"></a>语法规则实现</h3><pre><code>int start() throws NumberFormatException:{    Token a;    int i;    int value;}{    value=primary()    (        i=primary()        {value += i;}        )*    {return value;}}int primary() throws NumberFormatException:{    Token t;}{    t=    {return Integer.parseInt(t.image);}}</code></pre><h3 id="词法规则注意事项-举例"><a href="#词法规则注意事项-举例" class="headerlink" title="词法规则注意事项(举例)"></a>词法规则注意事项(举例)</h3><p>局部词法分析</p><p><img src="/img/javacc9.png" alt="img"></p><p>　在词法声明部分，以#号开头的token只是在词法分析时使用，而不能做法语法分析的输入，也就是说。它相对词法分析是局部的，内部的。</p><p><img src="/img/javacc10.png" alt="img"></p><h3 id="防止词法定义失效"><a href="#防止词法定义失效" class="headerlink" title="防止词法定义失效"></a>防止词法定义失效</h3><p>具有包含关系的词法定义，必须防止实现的情况，如果对于Key的声明必须定义在IDENTIFIER之前。这个问题最常见！！</p><p><img src="/img/javacc11.png" alt="img"></p><p><img src="/img/javacc12.png" alt="img"></p><p>–<br>举例：</p><pre><code>Encountered &quot;not ( employee&quot; at line 3, column 43.Wasexpecting one of: ...&quot;not&quot; &quot;(&quot; ...&quot;not&quot; &quot;(&quot;  ...</code></pre><p>(1) Token定义：</p><p>　　看上去,句子遇到 not 应该解析成 TOKEN not,其实不然,它会<br>被解析 TOKEN string.因为字符串 not 是符合 TOKEN string 的定义的,并<br>且在顺序上 TOKEN string 在前,所以先被匹配成 TOKEN string.如果将两<br>者的顺序更换一下,就能正确的解析成 TOKEN not 了</p><p>(2) 自定义变量导致的：</p><pre><code>void test(): {int not=0;}{    key=    {    not=1;    }}</code></pre><p>在这里，有一个自定义的变量名和 TOKEN not 名称一样。将 JJ 文件生成JAVA 类之后，你会发现，对于 TOKEN not显示的颜色，会跟其它的 TOKEN 不一样。这就是由于在 JAVA 类中，两个变量not 和 TOKEN not 二者冲突了。如果将这个变量名改为 no 或者其它的,TOKEN not 就能被正常解析了。</p><h3 id="语法规则注意事项"><a href="#语法规则注意事项" class="headerlink" title="语法规则注意事项"></a>语法规则注意事项</h3><p>语法部分决定了编译器的功能是否强大。</p><p>文法中没有每一个非终结符对应一个函数，函数调用表示非终结符之间的组成关系。</p><h4 id="明确编译器的主要功能"><a href="#明确编译器的主要功能" class="headerlink" title="明确编译器的主要功能"></a>明确编译器的主要功能</h4><p>语法分析阶段会存在二义性文法，在Eclipse代码中会有小黄三角，解决办法是个别冲突可以实现LOOKAHEAD(K)解决问题，比如在143行后加一个LOOKAHEAD(1),最好的方法是修改为非二义性文法，具体看编译原理书吧。</p><p><img src="/img/javacc13.png" alt="img"></p><h3 id="添加语义规则"><a href="#添加语义规则" class="headerlink" title="添加语义规则"></a>添加语义规则</h3><p>JavaCC采用自顶向下的语法分析，所以可以在文法的任意位置添加语义子程序</p><p>只需要在需要添加语义子程序的地方使用花括号即可；<br><img src="/img/javacc14.png" alt="img"></p><p>需要注意的是在1处添加的语义子程序，往往是用来实例化变量的，这些变量将在语法分析过程中被使用。</p><p><img src="/img/javacc15.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>https时代来了，你却还一无所知</title>
      <link href="/posts/6c03e1a0/"/>
      <url>/posts/6c03e1a0/</url>
      
        <content type="html"><![CDATA[<p>现在打开各大知名网站，你有没有发现地址栏都已经加了个绿色的小锁？</p><p>是的，这就是https，这就是https的时代。</p><h4 id="然而，你了解https吗？"><a href="#然而，你了解https吗？" class="headerlink" title="然而，你了解https吗？"></a>然而，你了解https吗？</h4><p>简单来说，https就是套在SSL/TLS内的http，也就是安全的http。何为安全？一个安全的网络通信环境要解决3个问题：</p><h4 id="通信内容的保密性"><a href="#通信内容的保密性" class="headerlink" title="通信内容的保密性"></a>通信内容的保密性</h4><h4 id="通信双方身份的真实性"><a href="#通信双方身份的真实性" class="headerlink" title="通信双方身份的真实性"></a>通信双方身份的真实性</h4><h4 id="通信内容的完整性"><a href="#通信内容的完整性" class="headerlink" title="通信内容的完整性"></a>通信内容的完整性</h4><p>而https就是为了解决这3大问题而诞生的（准确来说应该是ssl），下面分别看看这3个问题的解决方案。</p><h2 id="通信内容的保密性-1"><a href="#通信内容的保密性-1" class="headerlink" title="通信内容的保密性"></a>通信内容的保密性</h2><p>通信内容的保密需要通过加密来实现。我们的互联网环境是非常透明的，通信需要经过很多中转才能到接收方手中。这个情形有点像你上课的时候给第一排的小红递纸条一样，纸条上你肯定不会直接写今夜三更操场见，而是机灵地写了老地方见。这个老地方只有你和小红知道，这样就算小明小李看到了纸条，他们也不知道老地方是图书馆还是英语角，这就是加密，而老地方就是所谓的密钥。</p><p>当然，这个例子并不是很准确。简单来说，加解密就是一个函数，而密钥则是这个函数的参数。比如我们定义一个简单的加密函数，f(x)=x+b，x就是输入的明文，而b是密钥；解密函数就是加密函数的反函数，也就是g(x)=x-b。当不知道b的时候，你就算看到了密文也猜不出真实内容，这样就实现了加密。这种加解密都用同一个密钥，叫对称加密。</p><h4 id="但这里有个问题，这里的参数b是怎么协商出来的？"><a href="#但这里有个问题，这里的参数b是怎么协商出来的？" class="headerlink" title="但这里有个问题，这里的参数b是怎么协商出来的？"></a>但这里有个问题，这里的参数b是怎么协商出来的？</h4><p>你和小红可以花前月下约好b值，但是在真实网络环境中你和小红根本没有直接沟通的可能，所有沟通都要靠小明小李去传纸条的话，怎么做才能躲过他们呢？这里就需要用到非对称加密算法了，这种算法有公钥和私钥一对钥匙，公钥是所有人都能获取到的钥匙，私钥则是服务器私自保存的钥匙。非对称加密算法中公钥加密的内容只能用私钥解密，私钥加密的内容则只有公钥才能解密。所以当你使用小红的公钥加密你的纸条之后，帮你传递纸条小明小李等人看到纸条也无法读取内容了，只有拥有私钥的小红才能读出你的信息。</p><p>对称加密算法在加密和解密时使用的是同一个秘钥；而非对称加密算法需要两个密钥来进行加密和解密，这两个秘钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。你可能比较好奇非对称加密算法的原理，但是我这里不展开讲算法，有兴趣的同学可以自行搜索。<br>那么问题来了，小红给你的回应也想加密怎么办？如果小红用她的私钥加密的话，班上所有人都知道公钥，而公钥可以解私钥的加密，也意味着所有人都能解密小红的回应消息。聪明的你一定想到了解决方案：<br>利用非对称加密算法加密出一个对称密钥给小红，小红用她的私钥读取对称密钥，然后你们就用这个对称密钥来做对称加密，然后就可以愉快地约约约了。<br>当然，https也是这么干的。</p><h2 id="通信双方身份的真实性-1"><a href="#通信双方身份的真实性-1" class="headerlink" title="通信双方身份的真实性"></a>通信双方身份的真实性</h2><p>加密之后貌似通信过程就完美了？且慢，小红的公钥是怎么公告天下的呢？<br>要知道在网络环境中所有信息交互都是通过传纸条的方式来进行的，小红的公钥也不例外，万一在经过小明手里的时候被掉包了怎么办？怎么保证你手上的小红公钥是就是真正的小红公钥呢？看到班上的痴男怨女的纸条被各种掉包，文娱委员凤姐决定挺身而出。凤姐想出了一个办法，所有加密通信都要带上一本证，用来证明自己的身份。这本证是凤姐特意为班上所有单身狗做的，公钥就放在证书里面返回给纸条的发送者，证书里面除了公钥还有学号、人名、甚至星座身高三围等各种信息。证书上盖了一个大大的鉴定章，这是凤姐独有的章，表示证上的信息真实性由凤姐保证，看到这个章就可以认为对方是个真·单身狗。</p><p>通过这些信息你就可以知道对方是小红还是如花了，这就是证书机制。</p><p>显然你会怀疑证书上凤姐的公章是有可能被伪造的，怀疑有理！所以证书上的公章也是非对称加密过的，加密方式跟上面提到的刚好相反：用凤姐的私钥加密，用凤姐公钥就可以解密，这样就可以鉴定证书的真伪。这个公章就是证书的数字签名，具体来说就是先将证书用哈希算法提取摘要，然后对摘要进行加密的过程。另外你也可以直接拿着证书去找凤姐，凤姐就会帮你验证证书的有效性。（证书是有期限的，所以即使是真证书也会可能过期，需要注意）</p><p>这个机制看起来相当完善，但是我们要以怀疑一切的态度去做安全机制，凤姐保证的东西是可信任的了，但是，凤姐真的是凤姐吗？？？</p><p>所以，凤姐本身也要由证书来保证，凤姐的证书由班主任颁发，而班主任的证书由校长颁发……这个链一直到最权威的几个机构，这些机构在https体系中就是所谓的根CA。根是不可怀疑的权威，他们为自己带盐，自己证明自己是自己。在https证书体系里面，根证书是操作系统/浏览器自带的，我们可以相信被这些机构认证的证书的，从而一层一层推导到凤姐这个级别。</p><p>另外，由于证书其实很容易做，地铁口10块一本，无论哈佛还是斯坦福，统统10块！所以有些公司会自己做证书，根本不去找根CA机构，比如著名的12306。你也可以自己做证书放到网上让用户下载导入浏览器，但因为你没有凤姐的影响力，所以没人会相信你，当然也有人连凤姐都不相信……</p><h2 id="通信内容的完整性-1"><a href="#通信内容的完整性-1" class="headerlink" title="通信内容的完整性"></a>通信内容的完整性</h2><p>密也加了，凤姐也保证了，是不是这套机制就perfect了呢？<br>NoNoNo，想一下暗恋着你的小明看到你给小红传纸条，心里肯定不爽，虽然看不懂但是还是可以改密文呀。本来你是要约小红半夜三更操场见，结果小明删掉了前半部分的密文，解密后恰好变成了“操场见”，然后小红下课马上往操场跑，而你却跑回宿舍好好洗了个澡……然后，然后小红就跟小明跑了。。。</p><p>这种篡改通信内容的场景相信大家都深有体会，我们访问一些站点的时候无缘无故就出现了运营商的广告，这都是运营商给加的！！所以内容的完整性也需要保证，这比较简单：先用哈希算法提取内容摘要，然后对摘要进行加密生成数字签名，验证数字签名就可以判断出通信内容的完整性了。</p><h4 id="以上几点就是https用到技术的简化版，结合起来一个http通信流程如下："><a href="#以上几点就是https用到技术的简化版，结合起来一个http通信流程如下：" class="headerlink" title="以上几点就是https用到技术的简化版，结合起来一个http通信流程如下："></a>以上几点就是https用到技术的简化版，结合起来一个http通信流程如下：</h4><h4 id="大体步骤："><a href="#大体步骤：" class="headerlink" title="大体步骤："></a>大体步骤：</h4><p><img src="/img/https.png" alt="img"></p><p>客户端发送Client Hello报文开始SSL通信，报文中包含SSL版本、可用算法列表、密钥长度等。<br>服务器支持SSL通信时，会以Server Hello报文作为应答，报文中同样包括SSL版本以及加密算法配置，也就是协商加解密算法。<br>然后服务器会发送Certificate报文，也就是将证书发送给客户端。<br>客户端发送Client Key Exchange报文，使用3中的证书公钥加密Pre-master secret随机密码串，后续就以这个密码来做对称加密进行通信。<br>服务器使用私钥解密成功后返回一个响应提示SSL通信环境已经搭建好了。<br>然后就是常规的http c/s通信。<br>根据前文所述，在步骤3和步骤6都会使用摘要和签名算法来保证传递的证书和通信内容不被篡改。通过这个流程可以看出，https的核心在于加密，尤其是非对称加密算法被多次使用来传送关键信息。</p><h4 id="理解了加密，认识到网络的透明性，抱着怀疑一切的态度，理解https这套体系就变得简单了。"><a href="#理解了加密，认识到网络的透明性，抱着怀疑一切的态度，理解https这套体系就变得简单了。" class="headerlink" title="理解了加密，认识到网络的透明性，抱着怀疑一切的态度，理解https这套体系就变得简单了。"></a>理解了加密，认识到网络的透明性，抱着怀疑一切的态度，理解https这套体系就变得简单了。</h4><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>最近在系统地重温http相关的东西，这一篇先介绍了https的基本原理，才疏学浅，文中有不当之处，还望斧正！后续会介绍实际应用、静态服务器的配置等~</p><h2 id="附录："><a href="#附录：" class="headerlink" title="附录："></a>附录：</h2><h4 id="https如何避免中间人攻击？"><a href="#https如何避免中间人攻击？" class="headerlink" title="https如何避免中间人攻击？"></a>https如何避免中间人攻击？</h4><p>如果有人劫持了你的dns服务器，将<a href="http://wwe.icbc.com" target="_blank" rel="noopener">http://wwe.icbc.com</a> 解析到他的非法网站，或者代理服务器将你导向他的非法网站去，这都是中间人攻击。如果没有https，那么攻击就这样发生了。那https怎么避免这类攻击？</p><p>答案是通过证书鉴别。</p><ol><li><p>在申请证书的时候CA会对所要申请的域名进行控制权认证，所以你是不可能用隔壁老王的网站来申请证书的。就算你黑了他的站点，只要老王去申请证书就能发现了。</p></li><li><p>如果伪造一个证书，这个证不是权威CA签发的，那么浏览器检查的时候会报警提示用户证书非法。当然用户仍然可以继续操作，比如抢火车票什么的。。</p></li><li><p>如果你把真正站点的证书搞下来，证书上的域名不变，只是将公钥替换掉，那么浏览器比对证书数字签名的时候就能发现对不上了，二话不说，报警。</p></li><li><p>如果中间人直接用<a href="http://www.icbc.com的真实证书，那么他虽然能收到客户端的消息，但是无法解密，所以也无法响应客户端的请求，攻击无效！" target="_blank" rel="noopener">www.icbc.com的真实证书，那么他虽然能收到客户端的消息，但是无法解密，所以也无法响应客户端的请求，攻击无效！</a></p></li></ol><h4 id="证书的数字签名"><a href="#证书的数字签名" class="headerlink" title="证书的数字签名"></a>证书的数字签名</h4><p>之前对哈希算法和数字签名了解不多，了解之后发现其实原理还是挺简单的。哈希算法可以将大量的数据转换成定长的摘要，而且摘要是与输入对应的，输入变化后摘要也会发生变化。所以对数据应用哈希算法求出摘要，比对摘要就可以判断数据是否被篡改过了。证书使用了私钥加密摘要，然后客户端就可以用公钥解密得到摘要，对比哈希算法算出来的摘要就可以判断证书是否被篡改过。另一方面，因为公私钥是成对的，篡改后的证书虽然能求出摘要，但是无法加密出签名，所以摘要和加密组合使用就可以保证证书的真实性了。这里的私钥是证书的发证机构的私钥，也就是CA链上CA加密用户服务器证书，上级CA加密下级CA的证书，从而形成一个信任环。</p>]]></content>
      
      
      <categories>
          
          <category> 前端技术 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>区块链到底是什么？</title>
      <link href="/posts/804ba325/"/>
      <url>/posts/804ba325/</url>
      
        <content type="html"><![CDATA[<h4 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a>一、前言</h4><p>区块链无疑是当下最火的行业，社会上对区块链有很多的讨论，但是每个人谈到区块链的时候，他们口中的定义好像都不太一样。</p><p>也难怪，区块链发展到今天，整个行业的体量已经不小了，也已经有了很多不同的发展方向。</p><p>成语“盲人摸象”里面说，大象太大了，每个人去摸，摸到的都不一样，有些人摸到了大象腿，有些人摸到的是大象的鼻子，所以每个人口中的大象都不一样，每个人的口中的区块链也有点这个意思。</p><p>所以，每个新人朋友都会有这样的疑问：到底什么是区块链呢？</p><h4 id="二、区块链与区块链"><a href="#二、区块链与区块链" class="headerlink" title="二、区块链与区块链+"></a>二、区块链与区块链+</h4><p>社会上对区块链赋予了很多意义，有些说它是划时代的生产关系，有些说它是不可篡改的事实机器，有些说它是价值互联网，这些说法都有道理，但严格说来，这些都是“区块链+”的意义。</p><p>大概关系是这样的：</p><p>区块链+货币 = 比特币、BCH 区块链+智能合约 = ETH 区块链 + 资产上链 = BTM</p><p>所以，当你说到比特币有多伟大的时候，你其实在说区块链+货币的作用；当你说ICO的融资方式有多高效便捷的时候，你其实在说区块链+智能合约的作用；当你说到资产可编程、可高效流通的时候，你其实在说区块链 + 资产上链的作用。</p><h6 id="这些更多的是区块链-的意义，而不仅仅是区块链本身的意义。"><a href="#这些更多的是区块链-的意义，而不仅仅是区块链本身的意义。" class="headerlink" title="这些更多的是区块链+的意义，而不仅仅是区块链本身的意义。"></a>这些更多的是区块链+的意义，而不仅仅是区块链本身的意义。</h6><p>用一句调侃的话说，就好像吹气球，每个气球里的空气都是相同的，但不同形状的气球能吹出不同的造型。</p><h4 id="三、区块链是一种技术"><a href="#三、区块链是一种技术" class="headerlink" title="三、区块链是一种技术"></a>三、区块链是一种技术</h4><p>区块链是一种技术，而不是其它！</p><p>正如互联网，互联网发展到今天毫无疑问给我们的生活带来了翻天覆地的变化，无论是电子商务、视频内容、移动支付还是其它的一切。</p><p>但是回到本质，互联网就是TCP/IP协议所定义出来的一整套信息传输协议，其它的都是在互联网的技术基础上发展起来的业务，严格说来都叫互联网+。</p><p>而互联网本身是一种单纯的技术，正如区块链本身也是一种单纯的技术一样。<br>四、区块链=区块+链<br>既然明确了区块链是一种技术，那我们就从技术的角度来看一看区块链。</p><p>其实我觉得区块链这个名字已经定义的很精准了，顾名思义区块链就是“区块”和“链”，也即：</p><pre><code>区块链=区块+链</code></pre><h5 id="A、区块是什么？"><a href="#A、区块是什么？" class="headerlink" title="A、区块是什么？"></a>A、区块是什么？</h5><p>区块大致由以下几部分组成： 1、交易——区块链里的主要内容 2、区块结构——区块头、区块体、版本号、时间戳等固定格式 3、随机数——即POW工作量证明</p><p> <img src="/img/qkl.png" alt="img"></p><p> 这里先问一个问题：大家觉得一个区块与另一个区块之间是如何划分的呢？</p><p>不是通过时间，不是通过区块内交易的数量，也不是通过区块大小什么的，而是通过工作量证明计算出随机数。</p><p>这就是有意思的地方：如果你在1min之内，计算出来了随机数，那么就是1min出一个块；如果下一个块是在30min之内算出随机数，那么下一个块就是30min之后出。</p><p>也就是说，区块与区块之间，是依靠POW工作量证明来划分的。</p><h6 id="有POW，才有区块！没有POW，就没有区块！"><a href="#有POW，才有区块！没有POW，就没有区块！" class="headerlink" title="有POW，才有区块！没有POW，就没有区块！"></a>有POW，才有区块！没有POW，就没有区块！</h6><p>没有区块自然也就没有区块链！</p><h5 id="B、链是什么？-一个一个的区块，通过特定的规则组合起来，就形成了链。"><a href="#B、链是什么？-一个一个的区块，通过特定的规则组合起来，就形成了链。" class="headerlink" title="B、链是什么？ 一个一个的区块，通过特定的规则组合起来，就形成了链。"></a>B、链是什么？ 一个一个的区块，通过特定的规则组合起来，就形成了链。</h5><p>一般来说，链的形成，有以下几个步骤：</p><p>1、新区块的选择——一般来说，哪个区块先算出随机数，就以哪个区块为准；但如果有多个节点同时出块，就涉及到选择的问题了。 </p><p>2、网络传播——迅速将新生成的新区块广播出去，尽早传播到更多的节点。 </p><p>3、最长链形成——并在此基础上构建下一个区块。</p><p>当然，还有一些更为细节的组成，但是大致步骤就是以上三步。</p><p>其实链的形成过程，就是把全网不同节点的不同数据，收敛成确定且相同的数据的过程。</p><p>我们经常说共识，到底什么是共识？从技术角度来讲，最长链即共识！</p><h4 id="四、广义区块链"><a href="#四、广义区块链" class="headerlink" title="四、广义区块链"></a>四、广义区块链</h4><p>通过上面的描述我们已经清楚，只有采用POW共识机制才有区块可言，没有POW是没有区块这个概念的，那就更谈不上区块链了。</p><p>比如说你在EOS系统里面，就没有区块这个概念，因为它采用的是DPOS机制，21个节点合作记账。</p><p>比如IOTA的DAG模式，有向无环图，也没有区块，所以他们都不能叫做区块链。</p><p>我们并不是说EOS或者IOTA不好，只是说它不是真正意义上的区块链，它没有区块链的数据结构。</p><p>不过，虽然它们并不具有区块+链的数据结构，但是它们都是分布式共识的解决方案，它们都有具体的用处，我称之为“广义区块链”。</p><h4 id="五、区块链的意义"><a href="#五、区块链的意义" class="headerlink" title="五、区块链的意义"></a>五、区块链的意义</h4><p>所以我们现在清楚了，区块链 = 区块 + 链，区块链离不开POW工作量证明和最长链法则，可是，这样的区块链意义在哪里呢？</p><p>这里，我们要提一下著名的“不可能三角”，不可能三角现在已经演化出了很多版本，但是基本上最被大家认可的是——性能、安全和去中心化不可兼得。</p><p>按我们刚刚的说法，区块链用了特殊的区块结构，几分钟才出一个块，而且每个块容量有限，所以性能肯定不是很高；POW共识机制是可以保证安全的；所以区块链牺牲性能换回来安全与去中心化，尤其是去中心化这个特性；</p><p>具体的来讲，我们获得了一条链！这条链也就是共识！</p><p>综合起来，我们获得了在去中心化环境下的数据一致性。</p><h6 id="去中心环境下的数据一致性，这就是我所理解的区块链的技术意义。"><a href="#去中心环境下的数据一致性，这就是我所理解的区块链的技术意义。" class="headerlink" title="去中心环境下的数据一致性，这就是我所理解的区块链的技术意义。"></a>去中心环境下的数据一致性，这就是我所理解的区块链的技术意义。</h6><p>知道了区块链的技术意义，再来理解“区块链+”的意义，再来理解为什么说它是不可篡改的事实机器，为什么说它是价值互联网，也许会更透彻。</p>]]></content>
      
      
      <categories>
          
          <category> 后端技术 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区块链 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop中HDFS文件下载</title>
      <link href="/posts/f32ab55d/"/>
      <url>/posts/f32ab55d/</url>
      
        <content type="html"><![CDATA[<h3 id="原理说明"><a href="#原理说明" class="headerlink" title="原理说明"></a>原理说明</h3><p>首先客户端会跟namenode说我要拿取哪个目录下的哪个文件，比如是/hadoop/hdfs/目录下的cjk.avi文件。<br>namenode就会去元数据池中查找这个文件对应的各个block块，以及各个block块的位置信息（哪个datanode），<br>然后将这些信息发给客户端。客户端拿到信息后，就会去各个节点拿取每一块block，然后将数据拉取到本地。<br>接下来在client客户端本地对这些block块进行合并，这样就得到一个完整的文件了。</p><h3 id="原理图示"><a href="#原理图示" class="headerlink" title="原理图示"></a>原理图示</h3><p><img src="/img/hdfs.png" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop 生态圈</title>
      <link href="/posts/44e50408/"/>
      <url>/posts/44e50408/</url>
      
        <content type="html"><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Hadoop 是一个能够处理海量数据的分布式系统基础软件框架，理论上能够通过增加计算节点以处理无限增长的数据，由java写成。其作者是 Doug Cutting，得益于谷歌的Map/Reduce计算模型和GFS分布式文件系统，Hadoop实现了其核心组件HDFS和MapReducce。Hadoop 是目前世界上大数据行业的主流软件框架。其生态圈非常庞大，并且社区很活跃。Hadoop本身仅有hadoop-common + hdfs + mapreduce 组成，hadoop2.x以后增加了yarn体系。</p><h3 id="Hadoop的集群模式"><a href="#Hadoop的集群模式" class="headerlink" title="Hadoop的集群模式"></a>Hadoop的集群模式</h3><p>hadoop 集群，从细的方面来说，总共分为四种模式：</p><h5 id="Single-Node-Cluster，即伪分布式模式（单机模式）"><a href="#Single-Node-Cluster，即伪分布式模式（单机模式）" class="headerlink" title="Single Node Cluster，即伪分布式模式（单机模式）"></a>Single Node Cluster，即伪分布式模式（单机模式）</h5><h5 id="Full-Distributed-Cluster，即完全分布式集群模式"><a href="#Full-Distributed-Cluster，即完全分布式集群模式" class="headerlink" title="Full Distributed Cluster，即完全分布式集群模式"></a>Full Distributed Cluster，即完全分布式集群模式</h5><h5 id="HA-Cluster，即高可用集群模式"><a href="#HA-Cluster，即高可用集群模式" class="headerlink" title="HA Cluster，即高可用集群模式"></a>HA Cluster，即高可用集群模式</h5><h5 id="HA-Federation-Cluster，即高可用联邦集群模式"><a href="#HA-Federation-Cluster，即高可用联邦集群模式" class="headerlink" title="HA + Federation Cluster，即高可用联邦集群模式"></a>HA + Federation Cluster，即高可用联邦集群模式</h5><p>每一种方式都有其特定的使用场景，但一般数据规模很大的企业，都会选择HA+Federation模式，下面简要地介绍一下每一种模式的情况：</p><p>   单机模式，将hadoop安装在一台机器上，通过进程来模拟各主机节点的协作和运行，其可靠性、稳定性都是非常差的，并且具备糟糕的性能效率，没有团队会在生产环境使用它。那么它是否就没有用呢？也不是的，通常使用这种模式进行开发和调试工作。</p><p>   完全分布式模式，将hadoop部署在至少两台机子上，数据块副本的数量通常也设置为2以上。该模式的集群，无论规模多大，只拥有1台Namenode节点，且也是唯一Active的工作节点。Namenode（简称NN）相当于hadoop文件系统的管家，对集群的所有文件访问和操作都经由NN统一协调管理。可想，当集群规模越来越庞大时，仅有一台NN，必定是不堪重负，那么它很容易就会挂掉，一旦挂掉，不仅集群立即瘫痪，还很容易造成数据丢失。另外，该模式通常ResourceManager（RM）也仅部署1台，ResourceManager是yarn的管家，主要管理任务的执行，例如MapReduce任务。与NN类似，当集群提交的作业过于繁重时，其同样面临超负载的问题。那么此模式是否也无用武之地呢？也不是的，视业务、资金等情况而定，因为该模式日后也可以安全升级成高可用模式。</p><p>   高可用模式，一般来说，分为NN的高可用和RM的高可用。在完全分布式的基础上，增加备用NN和RM节点。NN高可用，也就是集群里面会部署两台NN（最多也只能两台），以形成主备NN节点，达到高可用的目的。RM高可用与NN高可用类似，也是在集群里部署备用RM节点。不过此种模式下集群里面依然只有一台NN/RM处于Active工作状态，另一台则处于Standby的等待状态。当Active的NN/RM出现问题无法工作时，Standby的那台则立即无缝切入，继续保障集群正常运转。这种模式是很多企业都使用的，但是依然有缺陷。什么缺陷呢？虽然集群的可用性问题解决了，但是性能瓶颈依然存在——仅有一台NN/RM，由于无法横向扩展，其很可能会超负载运行。</p><p>   高可用联邦模式，解决了单纯HA模式的性能瓶颈。单纯的HA模式NN和RM之间虽然配置了HA，但是依旧仅有一台NN或RM同时运行，这可能会导致了NN或RM的负载过重，从而造成整个集群的性能瓶颈。而联邦模式将整个HA集群再划分为两个以上的集群，不同的集群之间通过Federation进行连接，不同集群间可以共享数据节点，也可以不共享，可以互相访问和操作数据，也可以不。这样便做到了HA集群的横向扩展，从而移除了单纯HA模式同时仅有1台NN/RM工作所带来的性能瓶颈。Federation模式，相当于在多个集群之上又构建了一个集群层次，从数据访问的角度看，也可以简单的将其理解为一台路由器，而每一个HA集群则是单独的网络，不同网络间通过Federation路由器进行沟通。此模式是目前hadoop生态中最高的一种模式，适用于规模较大的企业。</p><h3 id="组件体系"><a href="#组件体系" class="headerlink" title="组件体系"></a>组件体系</h3><p>hadoop</p><p>hdfs</p><p>mapreduce</p><p>yarn</p><p>zookeeper</p><p>hive</p><p>hbase</p><p>sqoop</p><p>pig</p><p>Impala</p><p>dubbo</p><p>kudu</p><p>storm</p><p>kafka</p><p>flume</p><p>elasticsearch elk</p><p>mahout</p><p>ambari</p><p>avro</p><p>cassandra</p><p>chukwa</p><p>tez</p><p>spark</p><p>spark-streaming</p><p>spark-sql</p><p>spark-MLlib</p><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>hadoop </p><p>hdfs </p><p>mapreduce </p><p>fsimage </p><p>edits </p><p>namenode-metadata</p><p>yarn </p><p>zookeeper</p><p>Namenode </p><p>Secondary-Namenode </p><p>Datanode</p><p>ResourceManager(JobTracker)</p><p>NodeManager(TaskTracker)</p><p>ApplicationManager</p><p>ApplicationMaster</p><p>Container</p><p>JobHistoryServer</p><p>JobClient</p><p>JournalNode</p><p>hadoop1.x hadoop2.x HA federation</p>]]></content>
      
      
      <categories>
          
          <category> 大数据 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL基础（五）：表的继承和分区</title>
      <link href="/posts/698ef1d/"/>
      <url>/posts/698ef1d/</url>
      
        <content type="html"><![CDATA[<h4 id="一、表的继承："><a href="#一、表的继承：" class="headerlink" title="一、表的继承："></a>一、表的继承：</h4><p>这个概念对于很多已经熟悉其他数据库编程的开发人员而言会多少有些陌生，然而它的实现方式和设计原理却是简单易懂，现在就让我们从一个简单的例子开始吧。</p><h5 id="1-第一个继承表："><a href="#1-第一个继承表：" class="headerlink" title="1. 第一个继承表："></a>1. 第一个继承表：</h5><pre><code>CREATE TABLE cities (   --父表    name        text,    population float,    altitude     int);CREATE TABLE capitals ( --子表    state      char(2)) INHERITS (cities);</code></pre><p>capitals表继承自cities表的所有属性。在PostgreSQL里，一个表可以从零个或多个其它表中继承属性，而且一个查询既可以引用父表中的所有行，也可以引用父表的所有行加上其所有子表的行，其中后者是缺省行为。</p><pre><code>MyTest=# INSERT INTO cities values(&#39;Las Vegas&#39;, 1.53, 2174);  --插入父表INSERT 0 1MyTest=# INSERT INTO cities values(&#39;Mariposa&#39;,3.30,1953);     --插入父表INSERT 0 1MyTest=# INSERT INTO capitals values(&#39;Madison&#39;,4.34,845,&#39;WI&#39;);--插入子表INSERT 0 1MyTest=# SELECT name, altitude FROM cities WHERE altitude &gt; 500; --父表和子表的数据均被取出。   name     | altitude-----------+---------- Las Vegas |     2174 Mariposa   |     1953 Madison    |      845(3 rows)MyTest=# SELECT name, altitude FROM capitals WHERE altitude &gt; 500; --只有子表的数据被取出。  name   | altitude---------+---------- Madison |      845(1 row)</code></pre><p>如果希望只从父表中提取数据，则需要在SQL中加入ONLY关键字，如：</p><pre><code>MyTest=# SELECT name,altitude FROM ONLY cities WHERE altitude &gt; 500;   name     | altitude-----------+---------- Las Vegas |     2174 Mariposa   |     1953(2 rows)</code></pre><p>上例中cities前面的”ONLY”关键字表示该查询应该只对cities进行查找而不包括继承级别低于cities的表。许多我们已经讨论过的命令–SELECT，UPDATE和DELETE–支持这个”ONLY”符号。<br>在执行整表数据删除时，如果直接truncate父表，此时父表和其所有子表的数据均被删除，如果只是truncate子表，那么其父表的数据将不会变化，只是子表中的数据被清空。</p><pre><code>MyTest=# TRUNCATE TABLE cities;  --父表和子表的数据均被删除。TRUNCATE TABLEMyTest=# SELECT * FROM capitals; name | population | altitude | state------+------------+----------+-------(0 rows)</code></pre><h5 id="2-确定数据来源："><a href="#2-确定数据来源：" class="headerlink" title="2. 确定数据来源："></a>2. 确定数据来源：</h5><p>有时候你可能想知道某条记录来自哪个表。在每个表里我们都有一个系统隐含字段tableoid，它可以告诉你表的来源：</p><pre><code>MyTest=# SELECT tableoid, name, altitude FROM cities WHERE altitude &gt; 500; tableoid |   name    | altitude----------+-----------+----------    16532 | Las Vegas |     2174    16532 | Mariposa  |     1953    16538 | Madison   |      845(3 rows)</code></pre><p>以上的结果只是给出了tableoid，仅仅通过该值，我们还是无法看出实际的表名。要完成此操作，我们就需要和系统表pg_class进行关联，以通过tableoid字段从该表中提取实际的表名，见以下查询：</p><pre><code>MyTest=# SELECT p.relname, c.name, c.altitude FROM cities c,pg_class p WHERE c.altitude &gt; 500 and c.tableoid = p.oid; relname  |   name    | altitude----------+-----------+---------- cities    | Las Vegas |     2174 cities    | Mariposa   |     1953 capitals | Madison    |      845(3 rows)</code></pre><h5 id="3-数据插入的注意事项："><a href="#3-数据插入的注意事项：" class="headerlink" title="3. 数据插入的注意事项："></a>3. 数据插入的注意事项：</h5><p>继承并不自动从INSERT或者COPY中向继承级别中的其它表填充数据。在我们的例子里，下面的INSERT语句不会成功：</p><pre><code>INSERT INTO cities (name, population, altitude, state) VALUES (&#39;New York&#39;, NULL, NULL, &#39;NY&#39;);</code></pre><p>我们可能希望数据被传递到capitals表里面去，但是这是不会发生的：INSERT总是插入明确声明的那个表。</p><h5 id="4-多表继承："><a href="#4-多表继承：" class="headerlink" title="4. 多表继承："></a>4. 多表继承：</h5><p>一个表可以从多个父表继承，这种情况下它拥有父表们的字段的总和。子表中任意定义的字段也会加入其中。如果同一个字段名出现在多个父表中，或者同时出现在父表和子表的定义里，那么这些字段就会被”融合”，这样在子表里面就只有一个这样的字段。要想融合，字段必须是相同的数据类型，否则就会抛出一个错误。融合的字段将会拥有它所继承的字段的所有约束。</p><pre><code>CREATE TABLE parent1 (FirstCol integer);CREATE TABLE parent2 (FirstCol integer, SecondCol varchar(20));CREATE TABLE parent3 (FirstCol varchar(200));--子表child1将同时继承自parent1和parent2表，而这两个父表中均包含integer类型的FirstCol字段，因此child1可以创建成功。CREATE TABLE child1 (MyCol timestamp) INHERITS (parent1,parent2);--子表child2将不会创建成功，因为其两个父表中均包含FirstCol字段，但是它们的类型不相同。CREATE TABLE child2 (MyCol timestamp) INHERITS (parent1,parent3);--子表child3同样不会创建成功，因为它和其父表均包含FirstCol字段，但是它们的类型不相同。CREATE TABLE child3 (FirstCol varchar(20)) INHERITS(parent1);</code></pre><h5 id="5-继承和权限："><a href="#5-继承和权限：" class="headerlink" title="5. 继承和权限："></a>5. 继承和权限：</h5><p>表访问权限并不会自动继承。因此，一个试图访问父表的用户还必须具有访问它的所有子表的权限，或者使用ONLY关键字只从父表中提取数据。在向现有的继承层次添加新的子表的时候，请注意给它赋予所有权限。     </p><p>继承特性的一个严重的局限性是索引(包括唯一约束)和外键约束只施用于单个表，而不包括它们的继承的子表。这一点不管对引用表还是被引用表都是事实，因此在上面的例子里，如果我们声明cities.name为UNIQUE或者是一个PRIMARY KEY，那么也不会阻止capitals表拥有重复了名字的cities数据行。 并且这些重复的行缺省时在查询cities表的时候会显示出来。实际上，缺省时capitals将完全没有唯一约束，因此可能包含带有同名的多个行。你应该给capitals增加唯一约束，但是这样做也不会避免与cities的重复。类似，如果我们声明cities.name REFERENCES某些其它的表，这个约束不会自动广播到capitals。在这种条件下，你可以通过手工给capitals 增加同样的REFERENCES约束来做到这点。</p><h4 id="二、分区表："><a href="#二、分区表：" class="headerlink" title="二、分区表："></a>二、分区表：</h4><h5 id="1-概述分区表："><a href="#1-概述分区表：" class="headerlink" title="1. 概述分区表："></a>1. 概述分区表：</h5><pre><code>分区的意思是把逻辑上的一个大表分割成物理上的几块儿，分区可以提供若干好处：</code></pre><ul><li>某些类型的查询性能可以得到极大提升。</li><li>更新的性能也可以得到提升，因为表的每块的索引要比在整个数据集上的索引要小。如果索引不能全部放在内存里，那么在索引上的读和写都会产生更多的磁盘访问。</li><li>批量删除可以用简单地删除某个分区来实现。</li><li>将很少用的数据可以移动到便宜的、慢一些地存储介质上。<br>假设当前的数据库并不支持分区表，而我们的应用所需处理的数据量也非常大，对于这种应用场景，我们不得不人为的将该大表按照一定的规则，手工拆分成多个小表，让每个小表包含不同区间的数据。这样一来，我们就必须在数据插入、更新、删除和查询之前，先计算本次的指令需要操作的小表。对于有些查询而言，由于查询区间可能会跨越多个小表，这样我们又不得不将多个小表的查询结果进行union操作，以合并来自多个表的数据，并最终形成一个结果集返回给客户端。可见，如果我们正在使用的数据库不支持分区表，那么在适合其应用的场景下，我们就需要做很多额外的编程工作以弥补这一缺失。然而需要说明的是，尽管功能可以勉强应付，但是性能却和分区表无法相提并论。</li></ul><p>目前PostgreSQL支持的分区形式主要为以下两种：</p><ul><li>范围分区: 表被一个或者多个键字字段分区成”范围”，在这些范围之间没有重叠的数值分布到不同的分区里。比如，我们可以为特定的商业对象根据数据范围分区，或者根据标识符范围分区。</li><li>列表分区: 表是通过明确地列出每个分区里应该出现那些键字值实现的。</li></ul><h5 id="2-实现分区："><a href="#2-实现分区：" class="headerlink" title="2. 实现分区："></a>2. 实现分区：</h5><p>1). 创建”主表”，所有分区都从它继承。</p><pre><code>CREATE TABLE measurement (            --主表    city_id      int    NOT NULL,    logdate     date  NOT NULL,    peaktemp int,);  </code></pre><p>2). 创建几个”子”表，每个都从主表上继承。通常，这些”子”表将不会再增加任何字段。我们将把子表称作分区，尽管它们就是普通的PostgreSQL表。</p><pre><code>CREATE TABLE measurement_yy04mm02 ( ) INHERITS (measurement);CREATE TABLE measurement_yy04mm03 ( ) INHERITS (measurement);...CREATE TABLE measurement_yy05mm11 ( ) INHERITS (measurement);CREATE TABLE measurement_yy05mm12 ( ) INHERITS (measurement);CREATE TABLE measurement_yy06mm01 ( ) INHERITS (measurement);</code></pre><p>上面创建的子表，均已年、月的形式进行范围划分，不同年月的数据将归属到不同的子表内。这样的实现方式对于清空分区数据而言将极为方便和高效，即直接执行DROP TABLE语句删除相应的子表，之后在根据实际的应用考虑是否重建该子表(分区)。相比于直接DROP子表，PostgreSQL还提供了另外一种更为方便的方式来管理子表：</p><pre><code>ALTER TABLE measurement_yy06mm01 NO INHERIT measurement;</code></pre><p>和直接DROP相比，该方式仅仅是使子表脱离了原有的主表，而存储在子表中的数据仍然可以得到访问，因为此时该表已经被还原成一个普通的数据表了。这样对于数据库的DBA来说，就可以在此时对该表进行必要的维护操作，如数据清理、归档等，在完成诸多例行性的操作之后，就可以考虑是直接删除该表(DROP TABLE)，还是先清空该表的数据(TRUNCATE TABLE)，之后再让该表重新继承主表，如：</p><pre><code>ALTER TABLE measurement_yy06mm01 INHERIT measurement;</code></pre><p>3). 给分区表增加约束，定义每个分区允许的健值。同时需要注意的是，定义的约束要确保在不同的分区里不会有相同的键值。因此，我们需要将上面”子”表的定义修改为以下形式：</p><pre><code>CREATE TABLE measurement_yy04mm02 (    CHECK ( logdate &gt;= DATE &#39;2004-02-01&#39; AND logdate &lt; DATE &#39;2004-03-01&#39;)) INHERITS (measurement);CREATE TABLE measurement_yy04mm03 (    CHECK (logdate &gt;= DATE &#39;2004-03-01&#39; AND logdate &lt; DATE &#39;2004-04-01&#39;)) INHERITS (measurement);...CREATE TABLE measurement_yy05mm11 (    CHECK (logdate &gt;= DATE &#39;2005-11-01&#39; AND logdate &lt; DATE &#39;2005-12-01&#39;)) INHERITS (measurement);CREATE TABLE measurement_yy05mm12 (    CHECK (logdate &gt;= DATE &#39;2005-12-01&#39; AND logdate &lt; DATE &#39;2006-01-01&#39;)) INHERITS (measurement);CREATE TABLE measurement_yy06mm01 (    CHECK (logdate &gt;= DATE &#39;2006-01-01&#39; AND logdate &lt; DATE &#39;2006-02-01&#39;)) INHERITS (measurement);   4). 尽可能基于键值创建索引。如果需要，我们也同样可以为子表中的其它字段创建索引。CREATE INDEX measurement_yy04mm02_logdate ON measurement_yy04mm02 (logdate);CREATE INDEX measurement_yy04mm03_logdate ON measurement_yy04mm03 (logdate);...CREATE INDEX measurement_yy05mm11_logdate ON measurement_yy05mm11 (logdate);CREATE INDEX measurement_yy05mm12_logdate ON measurement_yy05mm12 (logdate);CREATE INDEX measurement_yy06mm01_logdate ON measurement_yy06mm01 (logdate);   </code></pre><p>5). 定义一个规则或者触发器，把对主表的修改重定向到适当的分区表。<br>如果数据只进入最新的分区，我们可以设置一个非常简单的规则来插入数据。我们必须每个月都重新定义这个规则，即修改重定向插入的子表名，这样它总是指向当前分区。</p><pre><code>CREATE OR REPLACE RULE measurement_current_partition ASON INSERT TO measurementDO INSTEADINSERT INTO measurement_yy06mm01 VALUES (NEW.city_id, NEW.logdate, NEW.peaktemp);</code></pre><p>其中NEW是关键字，表示新数据字段的集合。这里可以通过点(.)操作符来获取集合中的每一个字段。</p><p>我们可能想插入数据并且想让服务器自动定位应该向哪个分区插入数据。我们可以用像下面这样的更复杂的规则集来实现这个目标。</p><pre><code>CREATE RULE measurement_insert_yy04mm02 ASON INSERT TO measurement WHERE (logdate &gt;= DATE &#39;2004-02-01&#39; AND logdate &lt; DATE &#39;2004-03-01&#39;)DO INSTEADINSERT INTO measurement_yy04mm02 VALUES (NEW.city_id, NEW.logdate, NEW.peaktemp);...CREATE RULE measurement_insert_yy05mm12 ASON INSERT TO measurement WHERE (logdate &gt;= DATE &#39;2005-12-01&#39; AND logdate &lt; DATE &#39;2006-01-01&#39;)DO INSTEADINSERT INTO measurement_yy05mm12 VALUES (NEW.city_id, NEW.logdate, NEW.peaktemp);CREATE RULE measurement_insert_yy06mm01 ASON INSERT TO measurement WHERE (logdate &gt;= DATE &#39;2006-01-01&#39; AND logdate &lt; DATE &#39;2006-02-01&#39;)DO INSTEADINSERT INTO measurement_yy06mm01 VALUES (NEW.city_id, NEW.logdate, NEW.peaktemp);    </code></pre><p>请注意每个规则里面的WHERE子句正好匹配其分区的CHECK约束。</p><p>可以看出，一个复杂的分区方案可能要求相当多的DDL。在上面的例子里我们需要每个月创建一次新分区，因此写一个脚本自动生成需要的DDL是明智的。除此之外，我们还不难推断出，分区表对于新数据的批量插入操作有一定的抑制，这一点在Oracle中也同样如此。 </p><p>除了上面介绍的通过Rule的方式重定向主表的数据到各个子表，我们还可以通过触发器的方式来完成此操作，相比于基于Rule的重定向方法，基于触发器的方式可能会带来更好的插入效率，特别是针对非批量插入的情况。然而对于批量插入而言，由于Rule的额外开销是基于表的，而不是基于行的，因此效果会好于触发器方式。另一个需要注意的是，copy操作将会忽略Rules，如果我们想要通过COPY方法来插入数据，你只能将数据直接copy到正确的子表，而不是主表。这种限制对于触发器来说是不会造成任何问题的。基于Rule的重定向方式还存在另外一个问题，就是当插入的数据不在任何子表的约束中时，PostgreSQL也不会报错，而是将数据直接保留在主表中。</p><h6 id="6-添加新分区："><a href="#6-添加新分区：" class="headerlink" title="6). 添加新分区："></a>6). 添加新分区：</h6><p>这里将介绍两种添加新分区的方式，第一种方法简单且直观，我们只是创建新的子表，同时为其定义新的检查约束，如：</p><pre><code>CREATE TABLE measurement_y2008m02 (    CHECK ( logdate &gt;= DATE &#39;2008-02-01&#39; AND logdate &lt; DATE &#39;2008-03-01&#39; )) INHERITS (measurement);</code></pre><p>第二种方法的创建步骤相对繁琐，但更为灵活和实用。见以下四步：</p><pre><code>/* 创建一个独立的数据表(measurement_y2008m02)，该表在创建时以将来的主表(measurement)为模板，包含模板表的缺省值(DEFAULTS)和一致性约束(CONSTRAINTS)。*/CREATE TABLE measurement_y2008m02    (LIKE measurement INCLUDING DEFAULTS INCLUDING CONSTRAINTS);/* 为该表创建未来作为子表时需要使用的检查约束。*/ALTER TABLE measurement_y2008m02 ADD CONSTRAINT y2008m02    CHECK (logdate &gt;= DATE &#39;2008-02-01&#39; AND logdate &lt; DATE &#39;2008-03-01&#39;);/* 导入数据到该表。下面只是给出一种导入数据的方式作为例子。在导入数据之后，如有可能，还可以做进一步的数据处理，如数据转换、过滤等。*/\copy measurement_y2008m02 from &#39;measurement_y2008m02&#39;/* 在适当的时候，或者说在需要的时候，让该表继承主表。*/ALTER TABLE measurement_y2008m02 INHERIT measurement;</code></pre><p>7). 确保postgresql.conf里的配置参数constraint_exclusion是打开的。没有这个参数，查询不会按照需要进行优化。这里我们需要做的是确保该选项在配置文件中没有被注释掉。</p><pre><code>/&gt; pwd/opt/PostgreSQL/9.1/data/&gt; cat postgresql.conf | grep &quot;constraint_exclusion&quot;constraint_exclusion = partition        # on, off, or partition</code></pre><h4 id="3-分区和约束排除："><a href="#3-分区和约束排除：" class="headerlink" title="3. 分区和约束排除："></a>3. 分区和约束排除：</h4><p>约束排除(Constraint exclusion)是一种查询优化技巧，它改进了用上面方法定义的表分区的性能。比如：</p><pre><code>SET constraint_exclusion = on;SELECT count(*) FROM measurement WHERE logdate &gt;= DATE &#39;2006-01-01&#39;;</code></pre><p>如果没有约束排除，上面的查询会扫描measurement表中的每一个分区。打开了约束排除之后，规划器将检查每个分区的约束然后再视图证明该分区不需要被扫描，因为它不能包含任何符合WHERE子句条件的数据行。如果规划器可以证明这个，它就把该分区从查询规划里排除出去。</p><p>你可以使用EXPLAIN命令显示一个规划在constraint_exclusion打开和关闭情况下的不同。用上面方法设置的表的典型的缺省规划是：    </p><pre><code>SET constraint_exclusion = off;EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE &#39;2006-01-01&#39;;                                             QUERY PLAN----------------------------------------------------------------------------------------------- Aggregate  (cost=158.66..158.68 rows=1 width=0)   -&gt;  Append  (cost=0.00..151.88 rows=2715 width=0)         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)               Filter: (logdate &gt;= &#39;2006-01-01&#39;::date)         -&gt;  Seq Scan on measurement_yy04mm02 measurement  (cost=0.00..30.38 rows=543 width=0)               Filter: (logdate &gt;= &#39;2006-01-01&#39;::date)         -&gt;  Seq Scan on measurement_yy04mm03 measurement  (cost=0.00..30.38 rows=543 width=0)               Filter: (logdate &gt;= &#39;2006-01-01&#39;::date)...         -&gt;  Seq Scan on measurement_yy05mm12 measurement  (cost=0.00..30.38 rows=543 width=0)               Filter: (logdate &gt;= &#39;2006-01-01&#39;::date)         -&gt;  Seq Scan on measurement_yy06mm01 measurement  (cost=0.00..30.38 rows=543 width=0)               Filter: (logdate &gt;= &#39;2006-01-01&#39;::date)</code></pre><p>从上面的查询计划中可以看出，PostgreSQL扫描了所有分区。下面我们再看一下打开约束排除之后的查询计划：</p><pre><code>SET constraint_exclusion = on;EXPLAIN SELECT count(*) FROM measurement WHERE logdate &gt;= DATE &#39;2006-01-01&#39;;                                             QUERY PLAN----------------------------------------------------------------------------------------------- Aggregate  (cost=63.47..63.48 rows=1 width=0)   -&gt;  Append  (cost=0.00..60.75 rows=1086 width=0)         -&gt;  Seq Scan on measurement  (cost=0.00..30.38 rows=543 width=0)               Filter: (logdate &gt;= &#39;2006-01-01&#39;::date)         -&gt;  Seq Scan on measurement_yy06mm01 measurement  (cost=0.00..30.38 rows=543 width=0)               Filter: (logdate &gt;= &#39;2006-01-01&#39;::date)</code></pre><p>请注意，约束排除只由CHECK约束驱动，而不会由索引驱动。</p><p>目前版本的PostgreSQL中该配置的缺省值是partition，该值是介于on和off之间的一种行为方式，即规划器只会将约束排除应用于基于分区表的查询，而on设置则会为所有查询都进行约束排除，那么对于普通数据表而言，也将不得不承担由该机制而产生的额外开销。</p><p>约束排除在使用时有以下几点注意事项：</p><ul><li>约束排除只是在查询的WHERE子句包含约束的时候才生效。一个参数化的查询不会被优化，因为在运行时规划器不知道该参数会选择哪个分区。因此像CURRENT_DATE这样的函数必须避免。把分区键值和另外一个表的字段连接起来也不会得到优化。</li><li>在CHECK约束里面要避免跨数据类型的比较，因为目前规划器会无法证明这样的条件为假。比如，下面的约束会在x是整数字段的时候可用，但是在x是一个bigint的时候不能用：<br>CHECK (x = 1)<br>对于bigint字段，我们必须使用类似下面这样的约束：<br>CHECK (x = 1::bigint)<br>这个问题并不仅仅局限于bigint数据类型，它可能会发生在任何约束的缺省数据类型与其比较的字段的数据类型不匹配的场合。在提交的查询里的跨数据类型的比较通常是OK的，只是不能在CHECK条件里。</li><li>在主表上的UPDATE和DELETE命令并不执行约束排除。</li><li>在规划器进行约束排除时，主表上的所有分区的所有约束都将会被检查，因此，大量的分区会显著增加查询规划的时间。</li><li>在执行ANALYZE语句时，要为每一个分区都执行该命令，而不是仅仅对主表执行该命令。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL基础（四）：常用数据类型</title>
      <link href="/posts/33473bb8/"/>
      <url>/posts/33473bb8/</url>
      
        <content type="html"><![CDATA[<h4 id="一、数值类型："><a href="#一、数值类型：" class="headerlink" title="一、数值类型："></a>一、数值类型：</h4><p>下面是PostgreSQL所支持的数值类型的列表和简单说明：</p><table><thead><tr><th>名字</th><th>存储空间</th><th>描述</th><th>范围</th></tr></thead><tbody><tr><td>smallint</td><td>2 字节</td><td>小范围整数</td><td>-32768 到 +32767</td></tr><tr><td>integer</td><td>4 字节</td><td>常用的整数</td><td>-2147483648 到 +2147483647</td></tr><tr><td>bigint</td><td>8 字节</td><td>大范围的整数</td><td>-9223372036854775808 到 9223372036854775807</td></tr><tr><td>decimal</td><td>变长</td><td>用户声明精度，精确</td><td>无限制</td></tr><tr><td>numeric</td><td>变长</td><td>用户声明精度，精确</td><td>无限制</td></tr><tr><td>real</td><td>4 字节</td><td>变精度，不精确</td><td>6 位十进制数字精度</td></tr><tr><td>double</td><td>8 字节</td><td>变精度，不精确</td><td>15 位十进制数字精度</td></tr><tr><td>serial</td><td>4 字节</td><td>自增整数</td><td>1 到 +2147483647</td></tr><tr><td>bigserial</td><td>8 字节</td><td>大范围的自增整数</td><td>1 到 9223372036854775807</td></tr></tbody></table><h5 id="1-整数类型："><a href="#1-整数类型：" class="headerlink" title="1. 整数类型："></a>1. 整数类型：</h5><p>类型smallint、integer和bigint存储各种范围的全部是数字的数，也就是没有小数部分的数字。试图存储超出范围以外的数值将导致一个错误。常用的类型是integer，因为它提供了在范围、存储空间和性能之间的最佳平衡。一般只有在磁盘空间紧张的时候才使用smallint。而只有在integer的范围不够的时候才使用bigint，因为前者(integer)绝对快得多。</p><h5 id="2-任意精度数值："><a href="#2-任意精度数值：" class="headerlink" title="2. 任意精度数值："></a>2. 任意精度数值：</h5><p>类型numeric可以存储最多1000位精度的数字并且准确地进行计算。因此非常适合用于货币金额和其它要求计算准确的数量。不过，numeric类型上的算术运算比整数类型或者浮点数类型要慢很多。<br>numeric字段的最大精度和最大比例都是可以配置的。要声明一个类型为numeric的字段，你可以用下面的语法：</p><pre><code>NUMERIC(precision,scale)</code></pre><p>比如数字23.5141的精度为6，而刻度为4。<br>    在目前的PostgreSQL版本中，decimal和numeric是等效的。</p><h5 id="3-浮点数类型："><a href="#3-浮点数类型：" class="headerlink" title="3. 浮点数类型："></a>3. 浮点数类型：</h5><p>数据类型real和double是不准确的、牺牲精度的数字类型。不准确意味着一些数值不能准确地转换成内部格式并且是以近似的形式存储的，因此存储后再把数据打印出来可能显示一些缺失。</p><h5 id="4-Serial-序号-类型："><a href="#4-Serial-序号-类型：" class="headerlink" title="4. Serial(序号)类型："></a>4. Serial(序号)类型：</h5><p>serial和bigserial类型不是真正的类型，只是为在表中设置唯一标识做的概念上的便利。</p><pre><code>    CREATE TABLE tablename (        colname SERIAL    );</code></pre><p>等价于</p><pre><code>    CREATE SEQUENCE tablename_colname_seq;CREATE TABLE tablename(        colname integer DEFAULT nextval(&#39;tablename_colname_seq&#39;) NOT NULL    );</code></pre><p>这样，我们就创建了一个整数字段并且把它的缺省数值安排为从一个序列发生器取值。应用了一个NOT NULL约束以确保空值不会被插入。在大多数情况下你可能还希望附加一个UNIQUE或者PRIMARY KEY约束避免意外地插入重复的数值，但这个不是自动发生的。因此，如果你希望一个序列字段有一个唯一约束或者一个主键，那么你现在必须声明，就像其它数据类型一样。</p><p>还需要另外说明的是，一个serial类型创建的序列在其所属字段被删除时，该序列也将被自动删除，但是其它情况下是不会被删除的。因此，如果你想用同一个序列发生器同时给几个字段提供数据，那么就应该以独立对象的方式创建该序列发生器。 </p><h4 id="二、字符类型："><a href="#二、字符类型：" class="headerlink" title="二、字符类型："></a>二、字符类型：</h4><p>下面是PostgreSQL所支持的字符类型的列表和简单说明：<br>名字 |    描述<br>—|—<br>varchar(n)|     变长，有长度限制<br>char(n) |    定长,不足补空白<br>text |    变长，无长度限制</p><p>SQL 定义了两种基本的字符类型，varchar(n)和char(n)，这里的n是一个正整数。两种类型都可以存储最多n个字符长的字串，试图存储更长的字串到这些类型的字段里会产生一个错误，除非超出长度的字符都是空白，这种情况下该字串将被截断为最大长度。如果没有长度声明，char等于char(1)，而varchar则可以接受任何长度的字串。</p><pre><code>MyTest=&gt; CREATE TABLE testtable(first_col varchar(2));CREATE TABLEMyTest=&gt; INSERT INTO testtable VALUES(&#39;333&#39;);   --插入字符串的长度，超过其字段定义的长度，因此报错。ERROR:  value too long for type character varying(2)--插入字符串中，超出字段定义长度的部分是空格，因此可以插入，但是空白符被截断。MyTest=&gt; INSERT INTO testtable VALUES(&#39;33 &#39;);   INSERT 0 1MyTest=&gt; SELECT * FROM testtable; first_col----------- 33(1 row)这里需要注意的是，如果是将数值转换成char(n)或者varchar(n)，那么超长的数值将被截断成n个字符，而不会抛出错误。MyTest=&gt; select 1234::varchar(2); varchar--------- 12(1 row)</code></pre><p>最后需要提示的是，这三种类型之间没有性能差别，只不过是在使用char类型时增加了存储尺寸。虽然在某些其它的数据库系统里，char(n)有一定的性能优势，但在PostgreSQL里没有。在大多数情况下，应该使用text或者varchar。</p><h4 id="三、日期-时间类型："><a href="#三、日期-时间类型：" class="headerlink" title="三、日期/时间类型："></a>三、日期/时间类型：</h4><p>下面是PostgreSQL所支持的日期/时间类型的列表和简单说明：</p><table><thead><tr><th>名字</th><th>存储空间</th><th>描述</th><th>最低值</th><th>最高值</th><th>分辨率</th></tr></thead><tbody><tr><td>timestamp[无时区]</td><td>8字节</td><td>包括日期和时间</td><td>4713 BC</td><td>5874897AD</td><td>1毫秒/14位</td></tr><tr><td>timestamp[含时区]</td><td>8字节</td><td>日期和时间，带时区</td><td>4713 BC</td><td>5874897AD</td><td>1毫秒/14位</td></tr><tr><td>interval</td><td>12字节</td><td>时间间隔</td><td>-178000000年</td><td>178000000年</td><td>1毫秒/14位</td></tr><tr><td>date</td><td>4字节</td><td>只用于日期</td><td>4713 BC</td><td>32767AD</td><td>1天</td></tr><tr><td>time[无时区]</td><td>8字节</td><td>只用于一日内时间</td><td>00:00:00</td><td>24:00:00</td><td>1毫秒/14位</td></tr></tbody></table><h5 id="1-日期-时间输入"><a href="#1-日期-时间输入" class="headerlink" title="1. 日期/时间输入:"></a>1. 日期/时间输入:</h5><p>任何日期或者时间的文本输入均需要由单引号包围，就象一个文本字符串一样。</p><h6 id="1-日期"><a href="#1-日期" class="headerlink" title="1). 日期:"></a>1). 日期:</h6><p>以下为合法的日期格式列表：</p><table><thead><tr><th>例子</th><th>描述</th></tr></thead><tbody><tr><td>January 8, 1999</td><td>在任何datestyle输入模式下都无歧义</td></tr><tr><td>1999-01-08</td><td>ISO-8601格式，任何方式下都是1999年1月8号，(建议格式)</td></tr><tr><td>1/8/1999</td><td>歧义，在MDY下是1月8号；在 DMY模式下读做8月1日</td></tr><tr><td>1/18/1999</td><td>在MDY模式下读做1月18日，其它模式下被拒绝</td></tr><tr><td>01/02/03</td><td>MDY模式下的2003年1月2日；DMY模式下的2003年2月1日；YMD 模式下的2001年2月3日</td></tr><tr><td>1999-Jan-08</td><td>任何模式下都是1月8日</td></tr><tr><td>Jan-08-1999</td><td>任何模式下都是1月8日</td></tr><tr><td>08-Jan-1999</td><td>任何模式下都是1月8日</td></tr><tr><td>99-Jan-08</td><td>在YMD模式下是1月8日，否则错误</td></tr><tr><td>08-Jan-99</td><td>1月8日，除了在YMD模式下是错误的之外</td></tr><tr><td>Jan-08-99</td><td>1月8日，除了在YMD模式下是错误的之外</td></tr><tr><td>19990108</td><td>ISO-8601; 任何模式下都是1999年1月8日</td></tr><tr><td>990108</td><td>ISO-8601; 任何模式下都是1999年1月8日</td></tr></tbody></table><h6 id="2-时间："><a href="#2-时间：" class="headerlink" title="2). 时间："></a>2). 时间：</h6><p>以下为合法的时间格式列表：</p><table><thead><tr><th>例子</th><th>描述</th></tr></thead><tbody><tr><td>04:05:06.789</td><td>ISO 8601</td></tr><tr><td>04:05:06</td><td>ISO 8601</td></tr><tr><td>04:05</td><td>ISO 8601</td></tr><tr><td>040506</td><td>ISO 8601</td></tr><tr><td>04:05 AM</td><td>与04:05一样；AM不影响数值</td></tr><tr><td>04:05 PM</td><td>与16:05一样；输入小时数必须 &lt;= 12</td></tr><tr><td>04:05:06.789-8</td><td>ISO 8601</td></tr><tr><td>04:05:06-08:00</td><td>ISO 8601</td></tr><tr><td>04:05-08:00</td><td>ISO 8601</td></tr><tr><td>040506-08</td><td>ISO 8601</td></tr></tbody></table><h6 id="3-时间戳："><a href="#3-时间戳：" class="headerlink" title="3). 时间戳："></a>3). 时间戳：</h6><p>时间戳类型的有效输入由一个日期和时间的联接组成，后面跟着一个可选的时区。因此，1999-01-08 04:05:06和1999-01-08 04:05:06 -8:00都是有效的数值。</p><h5 id="2-示例："><a href="#2-示例：" class="headerlink" title="2. 示例："></a>2. 示例：</h5><h6 id="1-在插入数据之前先查看datestyle系统变量的值："><a href="#1-在插入数据之前先查看datestyle系统变量的值：" class="headerlink" title="1). 在插入数据之前先查看datestyle系统变量的值："></a>1). 在插入数据之前先查看datestyle系统变量的值：</h6><pre><code>MyTest=&gt; show datestyle; DateStyle----------- ISO, YMD(1 row)</code></pre><h6 id="2-创建包含日期、时间和时间戳类型的示例表："><a href="#2-创建包含日期、时间和时间戳类型的示例表：" class="headerlink" title="2). 创建包含日期、时间和时间戳类型的示例表："></a>2). 创建包含日期、时间和时间戳类型的示例表：</h6><pre><code>MyTest=&gt; CREATE TABLE testtable (id integer, date_col date, time_col time, timestamp_col timestamp);CREATE TABLE</code></pre><h6 id="3-插入数据："><a href="#3-插入数据：" class="headerlink" title="3). 插入数据："></a>3). 插入数据：</h6><pre><code>MyTest=&gt; INSERT INTO testtable(id,date_col) VALUES(1, DATE&#39;01/02/03&#39;);  --datestyle为YMDINSERT 0 1MyTest=&gt; SELECT id, date_col FROM testtable; id   |  date_col----+------------  1  | 2001-02-03(1 row)MyTest=&gt; set datestyle = MDY;SETMyTest=&gt; INSERT INTO testtable(id,date_col) VALUES(2, DATE&#39;01/02/03&#39;);  --datestyle为MDYINSERT 0 1MyTest=&gt; SELECT id,date_col FROM testtable; id   |  date_col----+------------  1  | 2001-02-03  2  | 2003-01-02 MyTest=&gt; INSERT INTO testtable(id,time_col) VALUES(3, TIME&#39;10:20:00&#39;);  --插入时间。INSERT 0 1MyTest=&gt; SELECT id,time_col FROM testtable WHERE time_col IS NOT NULL; id   | time_col----+----------  3   | 10:20:00(1 row)MyTest=&gt; INSERT INTO testtable(id,timestamp_col) VALUES(4, DATE&#39;01/02/03&#39;);INSERT 0 1MyTest=&gt; INSERT INTO testtable(id,timestamp_col) VALUES(5, TIMESTAMP&#39;01/02/03 10:20:00&#39;);INSERT 0 1MyTest=&gt; SELECT id,timestamp_col FROM testtable WHERE timestamp_col IS NOT NULL; id   |    timestamp_col----+---------------------  4  | 2003-01-02 00:00:00  5  | 2003-01-02 10:20:00(2 rows)</code></pre><h4 id="四、布尔类型："><a href="#四、布尔类型：" class="headerlink" title="四、布尔类型："></a>四、布尔类型：</h4><p>PostgreSQL支持标准的SQL boolean数据类型。boolean只能有两个状态之一：真(True)或 假(False)。该类型占用1个字节。<br>    “真”值的有效文本值是：</p><pre><code>TRUE&#39;t&#39;&#39;true&#39;&#39;y&#39;&#39;yes&#39;&#39;1&#39;</code></pre><p>而对于”假”而言，你可以使用下面这些：</p><pre><code>FALSE&#39;f&#39;&#39;false&#39;&#39;n&#39;&#39;no&#39;&#39;0&#39;</code></pre><p>见如下使用方式：</p><pre><code>MyTest=&gt; CREATE TABLE testtable (a boolean, b text);CREATE TABLEMyTest=&gt; INSERT INTO testtable VALUES(TRUE, &#39;sic est&#39;);INSERT 0 1MyTest=&gt; INSERT INTO testtable VALUES(FALSE, &#39;non est&#39;);INSERT 0 1MyTest=&gt; SELECT * FROM testtable; a  |    b---+--------- t  | sic est f  | non est(2 rows)   MyTest=&gt; SELECT * FROM testtable WHERE a; a  |    b---+--------- t  | sic est(1 row)   MyTest=&gt; SELECT * FROM testtable WHERE a = true; a  |    b---+--------- t  | sic est(1 row)</code></pre><p>五、位串类型：</p><p>位串就是一串1和0的字串。它们可以用于存储和视觉化位掩码。我们有两种类型的SQL位类型：bit(n)和bit varying(n); 这里的n是一个正整数。bit类型的数据必须准确匹配长度n; 试图存储短些或者长一些的数据都是错误的。类型bit varying数据是最长n的变长类型；更长的串会被拒绝。写一个没有长度的bit等效于bit(1)，没有长度的bit varying相当于没有长度限制。</p><p>针对该类型，最后需要提醒的是，如果我们明确地把一个位串值转换成bit(n)，那么它的右边将被截断或者在右边补齐零，直到刚好n位，而不会抛出任何错误。类似地，如果我们明确地把一个位串数值转换成bit varying(n)，如果它超过n位，那么它的右边将被截断。 见如下具体使用方式：    </p><pre><code>MyTest=&gt; CREATE TABLE testtable (a bit(3), b bit varying(5));CREATE TABLEMyTest=&gt; INSERT INTO testtable VALUES (B&#39;101&#39;, B&#39;00&#39;);INSERT 0 1MyTest=&gt; INSERT INTO testtable VALUES (B&#39;10&#39;, B&#39;101&#39;);ERROR:  bit string length 2 does not match type bit(3)MyTest=&gt; INSERT INTO testtable VALUES (B&#39;10&#39;::bit(3), B&#39;101&#39;);INSERT 0 1MyTest=&gt; SELECT * FROM testtable;  a  |  b-----+----- 101 | 00 100 | 101(2 rows)MyTest=&gt; SELECT B&#39;11&#39;::bit(3); bit----- 110(1 row)</code></pre><h4 id="六、数组："><a href="#六、数组：" class="headerlink" title="六、数组："></a>六、数组：</h4><h5 id="1-数组类型声明："><a href="#1-数组类型声明：" class="headerlink" title="1. 数组类型声明："></a>1. 数组类型声明：</h5><h6 id="1-创建字段含有数组类型的表。"><a href="#1-创建字段含有数组类型的表。" class="headerlink" title="1). 创建字段含有数组类型的表。"></a>1). 创建字段含有数组类型的表。</h6><pre><code>CREATE TABLE sal_emp (    name            text,    pay_by_quarter  integer[] --还可以定义为integer[4]或integer ARRAY[4]);</code></pre><h6 id="2-插入数组数据："><a href="#2-插入数组数据：" class="headerlink" title="2). 插入数组数据："></a>2). 插入数组数据：</h6><pre><code>MyTest=# INSERT INTO sal_emp VALUES (&#39;Bill&#39;, &#39;{11000, 12000, 13000, 14000}&#39;);INSERT 0 1MyTest=# INSERT INTO sal_emp VALUES (&#39;Carol&#39;, ARRAY[21000, 22000, 23000, 24000]);INSERT 0 1MyTest=# SELECT * FROM sal_emp; name  |      pay_by_quarter--------+--------------------------- Bill     | {11000,12000,13000,14000} Carol  | {21000,22000,23000,24000}(2 rows)    </code></pre><h5 id="2-访问数组："><a href="#2-访问数组：" class="headerlink" title="2. 访问数组："></a>2. 访问数组：</h5><p>和其他语言一样，PostgreSQL中数组也是通过下标数字(写在方括弧内)的方式进行访问，只是PostgreSQL中数组元素的下标是从1开始n结束。</p><pre><code>MyTest=# SELECT pay_by_quarter[3] FROM sal_emp; pay_by_quarter----------------          13000          23000(2 rows)MyTest=# SELECT name FROM sal_emp WHERE pay_by_quarter[1] &lt;&gt; pay_by_quarter[2]; name------ Bill Carol(2 rows)PostgreSQL中还提供了访问数组范围的功能，即ARRAY[脚标下界:脚标上界]。MyTest=# SELECT name,pay_by_quarter[1:3] FROM sal_emp; name  |   pay_by_quarter--------+--------------------- Bill     | {11000,12000,13000} Carol  | {21000,22000,23000}(2 rows)</code></pre><h5 id="3-修改数组："><a href="#3-修改数组：" class="headerlink" title="3. 修改数组："></a>3. 修改数组：</h5><h6 id="1-代替全部数组值："><a href="#1-代替全部数组值：" class="headerlink" title="1). 代替全部数组值："></a>1). 代替全部数组值：</h6><pre><code>--UPDATE sal_emp SET pay_by_quarter = ARRAY[25000,25000,27000,27000] WHERE name = &#39;Carol&#39;; 也可以。MyTest=# UPDATE sal_emp SET pay_by_quarter = &#39;{31000,32000,33000,34000}&#39; WHERE name = &#39;Carol&#39;;UPDATE 1MyTest=# SELECT * FROM sal_emp; name  |      pay_by_quarter--------+--------------------------- Bill     | {11000,12000,13000,14000} Carol  | {31000,32000,33000,34000}(2 rows)</code></pre><h6 id="2-更新数组中某一元素："><a href="#2-更新数组中某一元素：" class="headerlink" title="2). 更新数组中某一元素："></a>2). 更新数组中某一元素：</h6><pre><code>MyTest=# UPDATE sal_emp SET pay_by_quarter[4] = 15000 WHERE name = &#39;Bill&#39;;UPDATE 1MyTest=# SELECT * FROM sal_emp; name  |      pay_by_quarter--------+--------------------------- Carol  | {31000,32000,33000,34000} Bill     | {11000,12000,13000,15000}(2 rows)</code></pre><h6 id="3-更新数组某一范围的元素："><a href="#3-更新数组某一范围的元素：" class="headerlink" title="3). 更新数组某一范围的元素："></a>3). 更新数组某一范围的元素：</h6><pre><code>MyTest=# UPDATE sal_emp SET pay_by_quarter[1:2] = &#39;{37000,37000}&#39; WHERE name = &#39;Carol&#39;;UPDATE 1MyTest=# SELECT * FROM sal_emp; name  |      pay_by_quarter--------+--------------------------- Bill     | {11000,12000,13000,15000} Carol  | {37000,37000,33000,34000}(2 rows)</code></pre><h6 id="4-直接赋值扩大数组："><a href="#4-直接赋值扩大数组：" class="headerlink" title="4). 直接赋值扩大数组："></a>4). 直接赋值扩大数组：</h6><pre><code>MyTest=# UPDATE sal_emp SET pay_by_quarter[5] = 45000 WHERE name = &#39;Bill&#39;;UPDATE 1MyTest=# SELECT * FROM sal_emp; name  |         pay_by_quarter--------+--------------------------------- Carol  | {37000,37000,33000,34000} Bill     | {11000,12000,13000,15000,45000}(2 rows)</code></pre><h5 id="4-在数组中检索："><a href="#4-在数组中检索：" class="headerlink" title="4. 在数组中检索："></a>4. 在数组中检索：</h5><h6 id="1-最简单直接的方法："><a href="#1-最简单直接的方法：" class="headerlink" title="1). 最简单直接的方法："></a>1). 最简单直接的方法：</h6><pre><code>SELECT * FROM sal_emp WHERE pay_by_quarter[1] = 10000 OR                        pay_by_quarter[2] = 10000 OR                        pay_by_quarter[3] = 10000 OR                        pay_by_quarter[4] = 10000;    </code></pre><h6 id="2-更加有效的方法："><a href="#2-更加有效的方法：" class="headerlink" title="2). 更加有效的方法："></a>2). 更加有效的方法：</h6><pre><code>SELECT * FROM sal_emp WHERE 10000 = ANY (pay_by_quarter); --数组元素中有任何一个等于10000，where条件将成立。SELECT * FROM sal_emp WHERE 10000 = ALL (pay_by_quarter); --只有当数组中所有的元素都等于10000时，where条件才成立。</code></pre><h4 id="七、复合类型："><a href="#七、复合类型：" class="headerlink" title="七、复合类型："></a>七、复合类型：</h4><p>PostgreSQL中复合类型有些类似于C语言中的结构体，也可以被视为Oracle中的记录类型，但是还是感觉复合类型这个命名比较贴切。它实际上只是一个字段名和它们的数据类型的列表。PostgreSQL允许像简单数据类型那样使用复合类型。比如，表字段可以声明为一个复合类型。</p><h5 id="1-声明复合类型"><a href="#1-声明复合类型" class="headerlink" title="1. 声明复合类型:"></a>1. 声明复合类型:</h5><pre><code>下面是两个简单的声明示例：CREATE TYPE complex AS (    r double,    i double);  CREATE TYPE inventory_item AS (    name           text,    supplier_id   integer,    price            numeric);</code></pre><p>和声明一个数据表相比，声明类型时需要加AS关键字，同时在声明TYPE时不能定义任何约束。下面我们看一下如何在表中指定复合类型的字段，如：</p><pre><code>CREATE TABLE on_hand (    item      inventory_item,    count    integer);</code></pre><p>最后需要指出的是，在创建表的时候，PostgreSQL也会自动创建一个与该表对应的复合类型，名字与表字相同，即表示该表的复合类型。</p><h5 id="2-复合类型值输入："><a href="#2-复合类型值输入：" class="headerlink" title="2. 复合类型值输入："></a>2. 复合类型值输入：</h5><p>我们可以使用文本常量的方式表示复合类型值，即在圆括号里包围字段值并且用逗号分隔它们。你也可以将任何字段值用双引号括起，如果值本身包含逗号或者圆括号，那么就用双引号括起，对于上面的inventory_item复合类型的输入如下：</p><pre><code>&#39;(&quot;fuzzy dice&quot;,42,1.99)&#39;</code></pre><p>如果希望类型中的某个字段为NULL，只需在其对应的位置不予输入即可，如下面的输入中price字段的值为NULL，</p><pre><code>&#39;(&quot;fuzzy dice&quot;,42,)&#39;</code></pre><p>如果只是需要一个空字串，而非NULL，写一对双引号，如：</p><pre><code>&#39;(&quot;&quot;,42,)&#39;</code></pre><p>在更多的场合中PostgreSQL推荐使用ROW表达式来构建复合类型值，使用该种方式相对简单，无需考虑更多标识字符问题，如：</p><pre><code>ROW(&#39;fuzzy dice&#39;, 42, 1.99)ROW(&#39;&#39;, 42, NULL)</code></pre><p>注：对于ROW表达式，如果里面的字段数量超过1个，那么关键字ROW就可以省略，因此以上形式可以简化为：</p><pre><code>(&#39;fuzzy dice&#39;, 42, 1.99)(&#39;&#39;, 42, NULL)</code></pre><h5 id="3-访问复合类型："><a href="#3-访问复合类型：" class="headerlink" title="3. 访问复合类型："></a>3. 访问复合类型：</h5><p>访问复合类型中的字段和访问数据表中的字段在形式上极为相似，只是为了对二者加以区分，PostgreSQL设定在访问复合类型中的字段时，类型部分需要用圆括号括起，以避免混淆，如：</p><pre><code>SELECT (item).name FROM on_hand WHERE (item).price &gt; 9.99;</code></pre><p>如果在查询中也需要用到表名，那么表名和类型名都需要被圆括号括起，如：</p><pre><code>SELECT (on_hand.item).name FROM on_hand WHERE (on_hand.item).price &gt; 9.99;</code></pre><h5 id="4-修改复合类型："><a href="#4-修改复合类型：" class="headerlink" title="4. 修改复合类型："></a>4. 修改复合类型：</h5><p>见如下几个示例：</p><pre><code>--直接插入复合类型的数据，这里是通过ROW表达式来完成的。INSERT INTO on_hand(item) VALUES(ROW(&quot;fuzzy dice&quot;,42,1.99));--在更新操作中，也是可以通过ROW表达式来完成。UPDATE on_hand SET item = ROW(&quot;fuzzy dice&quot;,42,1.99) WHERE count = 0;--在更新复合类型中的一个字段时，我们不能在SET后面出现的字段名周围加圆括号，--但是在等号右边的表达式里引用同一个字段时却需要圆括号。UPDATE on_hand SET item.price = (item).price + 1 WHERE count = 0;--可以在插入中，直接插入复合类型中字段。INSERT INTO on_hand (item.supplier_id, item.price) VALUES(100, 2.2);</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL基础（三）：模式Schema</title>
      <link href="/posts/8c0e2d51/"/>
      <url>/posts/8c0e2d51/</url>
      
        <content type="html"><![CDATA[<h6 id="一个数据库包含一个或多个命名的模式，模式又包含表。"><a href="#一个数据库包含一个或多个命名的模式，模式又包含表。" class="headerlink" title="一个数据库包含一个或多个命名的模式，模式又包含表。"></a>一个数据库包含一个或多个命名的模式，模式又包含表。</h6><p>模式还包含其它命名的对象，包括数据类型、函数，以及操作符。同一个对象名可以在不同的模式里使用而不会导致冲突；比如，schema1和myschema都可以包含叫做mytable的表。和数据库不同，模式不是严格分离的：一个用户可以访问他所连接的数据库中的任意模式中的对象，只要他有权限。</p><p>我们需要模式有以下几个主要原因：</p><ul><li>允许多个用户使用一个数据库而不会干扰其它用户。</li><li>把数据库对象组织成逻辑组，让它们更便于管理。</li><li>第三方的应用可以放在不同的模式中，这样它们就不会和其它对象的名字冲突。</li></ul><h4 id="1-创建模式："><a href="#1-创建模式：" class="headerlink" title="1. 创建模式："></a>1. 创建模式：</h4><pre><code>CREATE SCHEMA myschema;</code></pre><p>通过以上命令可以创建名字为myschema的模式，在该模式被创建后，其便可拥有自己的一组逻辑对象，如表、视图和函数等。</p><h4 id="2-public模式："><a href="#2-public模式：" class="headerlink" title="2. public模式："></a>2. public模式：</h4><p>在介绍后面的内容之前，这里我们需要先解释一下public模式。每当我们创建一个新的数据库时，PostgreSQL都会为我们自动创建该模式。当登录到该数据库时，如果没有特殊的指定，我们将以该模式(public)的形式操作各种数据对象，如：</p><pre><code> CREATE TABLE products ( ... ) 等同于 CREATE TABLE public.products ( ... )</code></pre><h4 id="3-权限："><a href="#3-权限：" class="headerlink" title="3. 权限："></a>3. 权限：</h4><p>缺省时，用户看不到模式中不属于他们所有的对象。为了让他们看得见，模式的所有者需要在模式上赋予USAGE权限。为了让用户使用模式中的对象，我们可能需要赋予额外的权限，只要是适合该对象的。PostgreSQL根据不同的对象提供了不同的权限类型，如：</p><pre><code>GRANT ALL ON SCHEMA myschema TO public;</code></pre><p>上面的ALL关键字将包含CREATE和USAGE两种权限。如果public模式拥有了myschema模式的CREATE权限，那么登录到该模式的用户将可以在myschema模式中创建任意对象，如：</p><pre><code>CREATE TABLE myschema.products (    product_no integer,    name text,    price numeric CHECK (price &gt; 0),);</code></pre><p>在为模式下的所有表赋予权限时，需要将权限拆分为各种不同的表操作，如：</p><pre><code>ALTER DEFAULT PRIVILEGES IN SCHEMA myschemaGRANT INSERT, SELECT, UPDATE, DELETE, TRUNCATE, REFERENCES, TRIGGER ON TABLES TO public;</code></pre><p>在为模式下的所有Sequence序列对象赋予权限时，需要将权限拆分为各种不同的Sequence操作，如：</p><pre><code>ALTER DEFAULT PRIVILEGES IN SCHEMA myschemaGRANT SELECT, UPDATE, USAGE ON SEQUENCES TO public;</code></pre><p>在为模式下的所有函数赋予权限时，仅考虑执行权限，如：</p><pre><code>ALTER DEFAULT PRIVILEGES IN SCHEMA myschemaGRANT EXECUTE ON FUNCTIONS TO public;</code></pre><p>可以看出，通过以上方式在public模式下为myschema模式创建各种对象是极为不方便的。下面我们将要介绍另外一种方式，即通过role对象，直接登录并关联到myschema对象，之后便可以在myschema模式下直接创建各种所需的对象了。</p><pre><code>CREATE ROLE myschema LOGIN PASSWORD &#39;123456&#39;; --创建了和该模式关联的角色对象。CREATE SCHEMA myschema AUTHORIZATION myschema; --该模式关联到指定的角色，模式名和角色名可以不相等。</code></pre><p>Linux Shell下，以myschema的角色登录到数据库MyTest，在密码输入正确后将成功登录到该数据库。</p><pre><code>/&gt; psql -d MyTest -U myschemaPassword:MyTest=&gt; CREATE TABLE test(i integer);CREATE TABLEMyTest=&gt; \d   --查看该模式下，以及该模式有权限看到的tables信息列表。          List of relations Schema     |   Name   | Type  |  Owner------------+---------+------+---------- myschema |   test     | table  | myschema(1 rows)</code></pre><h4 id="4-删除模式："><a href="#4-删除模式：" class="headerlink" title="4. 删除模式："></a>4. 删除模式：</h4><pre><code>DROP SCHEMA myschema;</code></pre><p>如果要删除模式及其所有对象，请使用级联删除：</p><pre><code>DROP SCHEMA myschema CASCADE;</code></pre><h4 id="5-模式搜索路径："><a href="#5-模式搜索路径：" class="headerlink" title="5. 模式搜索路径："></a>5. 模式搜索路径：</h4><p>我们在使用一个数据库对象时可以使用它的全称来定位对象，然而这样做往往也是非常繁琐的，每次都不得不键入owner_name.object_name。PostgreSQL中提供了模式搜索路径，这有些类似于Linux中的$PATH环境变量，当我们执行一个Shell命令时，只有该命令位于$PATH的目录列表中，我们才可以通过命令名直接执行，否则就需要输入它的全路径名。PostgreSQL同样也通过查找一个搜索路径来判断一个表究竟是哪个表，这个路径是一个需要查找的模式列表。在搜索路径里找到的第一个表将被当作选定的表。如果在搜索路径中 没有匹配表，那么就报告一个错误，即使匹配表的名字在数据库其它的模式中存在也如此。</p><p>在搜索路径中的第一个模式叫做当前模式。除了是搜索的第一个模式之外，它还是在CREATE TABLE没有声明模式名的时候，新建表所属于的模式。要显示当前搜索路径，使用下面的命令：</p><pre><code>MyTest=&gt; SHOW search_path;  search_path---------------- &quot;$user&quot;,public(1 row)</code></pre><p>可以将新模式加入到搜索路径中，如：</p><pre><code>SET search_path TO myschema,public;</code></pre><p>为搜索路径设置指定的模式，如：</p><pre><code>SET search_path TO myschema; --当前搜索路径中将只是包含myschema一种模式。</code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL基础（二）：数据表</title>
      <link href="/posts/e9b10ee9/"/>
      <url>/posts/e9b10ee9/</url>
      
        <content type="html"><![CDATA[<h4 id="一、表的定义："><a href="#一、表的定义：" class="headerlink" title="一、表的定义："></a>一、表的定义：</h4><p>对于任何一种关系型数据库而言，表都是数据存储的最核心、最基础的对象单元。现在就让我们从这里起步吧。</p><h5 id="1-创建表："><a href="#1-创建表：" class="headerlink" title="1. 创建表："></a>1. 创建表：</h5><pre><code>    CREATE TABLE products (        product_no integer,        name text,        price numeric    );</code></pre><h5 id="2-删除表："><a href="#2-删除表：" class="headerlink" title="2. 删除表："></a>2. 删除表：</h5><pre><code>    DROP TABLE products;</code></pre><h5 id="3-创建带有缺省值的表："><a href="#3-创建带有缺省值的表：" class="headerlink" title="3. 创建带有缺省值的表："></a>3. 创建带有缺省值的表：</h5><pre><code>    CREATE TABLE products (        product_no integer,        name text,        price numeric DEFAULT 9.99 --DEFAULT是关键字，其后的数值9.99是字段price的默认值。    );    CREATE TABLE products (        product_no SERIAL,  --SERIAL类型的字段表示该字段为自增字段，完全等同于Oracle中的Sequence。        name text,        price numeric DEFAULT 9.99    );</code></pre><p>输出为：</p><pre><code>NOTICE:  CREATE TABLE will create implicit sequence &quot;products_product_no_seq&quot; for serial column &quot;products.product_no&quot;</code></pre><h5 id="4-约束："><a href="#4-约束：" class="headerlink" title="4. 约束："></a>4. 约束：</h5><p>检查约束是表中最为常见的约束类型，它允许你声明在某个字段里的数值必须满足一个布尔表达式。不仅如此，我们也可以声明表级别的检查约束。</p><pre><code>    CREATE TABLE products (        product_no integer,        name text,        --price字段的值必须大于0，否则在插入或修改该字段值是，将引发违规错误。还需要说明的是，该检查约束        --是匿名约束，即在表定义时没有显示命名该约束，这样PostgreSQL将会根据当前的表名、字段名和约束类型，        --为该约束自动命名，如：products_price_check。        price numeric CHECK (price &gt; 0)    );    CREATE TABLE products (        product_no integer,        name text,        --该字段的检查约束被显示命名为positive_price。这样做好处在于今后维护该约束时，可以根据该名进行直接操作。        price numeric CONSTRAINT positive_price CHECK (price &gt; 0)    );</code></pre><p>下面的约束是非空约束，即约束的字段不能插入空值，或者是将已有数据更新为空值。</p><pre><code>CREATE TABLE products (    product_no integer NOT NULL,    name text NOT NULL,    price numeric);</code></pre><p>如果一个字段中存在多个约束，在定义时可以不用考虑约束的声明顺序。</p><pre><code>CREATE TABLE products (    product_no integer NOT NULL,    name text NOT NULL,    price numeric NOT NULL CHECK (price &gt; 0));</code></pre><p>唯一性约束，即指定的字段不能插入重复值，或者是将某一记录的值更新为当前表中的已有值。</p><pre><code>CREATE TABLE products (    product_no integer UNIQUE,    name text,    price numeric);CREATE TABLE products (    product_no integer,    name text,    price numeric,    UNIQUE (product_no));</code></pre><p>为表中的多个字段定义联合唯一性。</p><pre><code>CREATE TABLE example (    a integer,    b integer,    c integer,    UNIQUE (a, c));</code></pre><p>为唯一性约束命名。</p><pre><code>CREATE TABLE products (    product_no integer CONSTRAINT must_be_different UNIQUE,    name text,    price numeric);</code></pre><p>在插入数据时，空值(NULL)之间被视为不相等的数据，因此对于某一唯一性字段，可以多次插入空值。然而需要注意的是，这一规则并不是被所有数据库都遵守，因此在进行数据库移植时可能会造成一定的麻烦。</p><h5 id="5-主键和外键："><a href="#5-主键和外键：" class="headerlink" title="5. 主键和外键："></a>5. 主键和外键：</h5><p>从技术上来讲，主键约束只是唯一约束和非空约束的组合。</p><pre><code>CREATE TABLE products (    product_no integer PRIMARY KEY,  --字段product_no被定义为该表的唯一主键。    name text,    price numeric);</code></pre><p>和唯一性约束一样，主键可以同时作用于多个字段，形成联合主键：</p><pre><code>CREATE TABLE example (    a integer,    b integer,    c integer,    PRIMARY KEY (b, c));</code></pre><p>外键约束声明一个字段（或者一组字段）的数值必须匹配另外一个表中某些行出现的数值。 我们把这个行为称做两个相关表之间的参考完整性。</p><pre><code>CREATE TABLE orders (    order_id integer PRIMARY KEY, --该表也可以有自己的主键。    --该表的product_no字段为上面products表主键(product_no)的外键。    product_no integer REFERENCES products(product_no),    quantity integer);CREATE TABLE t1 (    a integer PRIMARY KEY,    b integer,    c integer,    --该外键的字段数量和被引用表中主键的数量必须保持一致。    FOREIGN KEY (b, c) REFERENCES example (b, c));  </code></pre><p>当多个表之间存在了主外键的参考性约束关系时，如果想删除被应用表(主键表)中的某行记录，由于该行记录的主键字段值可能正在被其引用表(外键表)中某条记录所关联，所以删除操作将会失败。如果想完成此操作，一个显而易见的方法是先删除引用表中和该记录关联的行，之后再删除被引用表中的该行记录。然而需要说明的是，PostgreSQL为我们提供了更为方便的方式完成此类操作。</p><pre><code>CREATE TABLE products (    product_no integer PRIMARY KEY,    name text,    price numeric);CREATE TABLE orders (    order_id integer PRIMARY KEY,    shipping_address text);CREATE TABLE order_items (    product_no integer REFERENCES products ON DELETE RESTRICT, --限制选项    order_id integer REFERENCES orders ON DELETE CASCADE, --级联删除选项    quantity integer,    PRIMARY KEY (product_no, order_id));</code></pre><p>限制和级联删除是两种最常见的选项。RESTRICT禁止删除被引用的行。<br>NO ACTION 的意思是如果在检查约束的时候，如果还存在任何引用行，则抛出错误； 如果你不声明任何东西，那么它就是缺省的行为。(这两个选择的实际区别是，NO ACTION 允许约束检查推迟到事务的晚些时候，而 RESTRICT 不行。) CASCADE声明在删除一个被引用的行的时候，引用它的行也会被自动删除掉。 在外键字段上的动作还有两个选项： SET NULL 和 SET DEFAULT。 这样会导致在被引用行删除的时候，引用它们的字段分别设置为空或者缺省值。</p><p>请注意这些选项并不能让你逃脱被观察和约束的境地。比如，如果一个动作声明 SET DEFAULT，但是缺省值并不能满足外键，那么动作就会失败。类似ON DELETE，还有ON UPDATE 选项，它是在被引用字段修改(更新)的时候调用的。可用的动作是一样的。</p><h4 id="二、系统字段："><a href="#二、系统字段：" class="headerlink" title="二、系统字段："></a>二、系统字段：</h4><p>PostgreSQL的每个数据表中都包含几个隐含定义的系统字段。因此，这些名字不能用于用户定义的字段名。这些系统字段的功能有些类似于Oracle中的rownum和rowid等。</p><ul><li>oid: 行的对象标识符(对象ID)。这个字段只有在创建表的时候使用了WITH OIDS，或者是设置了配置参数default_with_oids时出现。这个字段的类型是oid(和字段同名)。</li><li>tableoid: 包含本行的表的OID。这个字段对那些从继承层次中选取的查询特别有用，因为如果没有它的话，我们就很难说明一行来自哪个独立的表。tableoid可以和pg_class的oid字段连接起来获取表名字。</li><li>xmin: 插入该行版本的事务的标识(事务ID)。</li><li>cmin: 在插入事务内部的命令标识(从零开始)。</li><li>xmax: 删除事务的标识(事务ID)，如果不是被删除的行版本，那么是零。</li><li>cmax: 在删除事务内部的命令标识符，或者是零。</li><li>ctid: 一个行版本在它所处的表内的物理位置。请注意，尽管ctid可以用于非常快速地定位行版本，但每次VACUUM FULL之后，一个行的ctid都会被更新或者移动。因此ctid是不能作为长期的行标识符的。   </li><li>OID是32位的量，是在同一个集群内通用的计数器上赋值的。对于一个大型或者长时间使用的数据库，这个计数器是有可能重叠的。因此，假设OID是唯一的是非常错误的，除非你自己采取了措施来保证它们是唯一的。如果你需要标识表中的行，我们强烈建议使用序列号生成器。     </li></ul><h4 id="三、表的修改："><a href="#三、表的修改：" class="headerlink" title="三、表的修改："></a>三、表的修改：</h4><h5 id="1-增加字段："><a href="#1-增加字段：" class="headerlink" title="1. 增加字段："></a>1. 增加字段：</h5><pre><code>ALTER TABLE products ADD COLUMN description text;</code></pre><p>新增的字段对于表中已经存在的行而言最初将先填充所给出的缺省值(如果你没有声明DEFAULT子句，那么缺省是空值)。</p><p>在新增字段时，可以同时给该字段指定约束。</p><pre><code>    ALTER TABLE products ADD COLUMN description text CHECK(description &lt;&gt; &#39;&#39;);</code></pre><h5 id="2-删除字段："><a href="#2-删除字段：" class="headerlink" title="2. 删除字段："></a>2. 删除字段：</h5><pre><code>ALTER TABLE products DROP COLUMN description;</code></pre><p>如果该表为被引用表，该字段为被引用字段，那么上面的删除操作将会失败。如果要想在删除被引用字段的同时级联的删除其所有引用字段，可以采用下面的语法形式。</p><pre><code>  ALTER TABLE products DROP COLUMN description CASCADE;</code></pre><h5 id="3-增加约束："><a href="#3-增加约束：" class="headerlink" title="3. 增加约束："></a>3. 增加约束：</h5><pre><code>ALTER TABLE products ADD CHECK(name &lt;&gt; &#39;&#39;);  --增加一个表级约束ALTER TABLE products ADD CONSTRAINT some_name UNIQUE(product_no);--增加命名的唯一性约束。ALTER TABLE products ADD FOREIGN KEY(pdt_grp_id) REFERENCES pdt_grps; --增加外键约束。ALTER TABLE products ALTER COLUMN product_no SET NOT NULL; --增加一个非空约束。</code></pre><h5 id="4-删除约束："><a href="#4-删除约束：" class="headerlink" title="4. 删除约束："></a>4. 删除约束：</h5><pre><code>ALTER TABLE products DROP CONSTRAINT some_name;</code></pre><p>对于显示命名的约束，可以根据其名称直接删除，对于隐式自动命名的约束，可以通过psql的\d tablename来获取该约束的名字。和删除字段一样，如果你想删除有着被依赖关系地约束，你需要用CASCADE。一个例子是某个外键约束依赖被引用字段上的唯一约束或者主键约束。如：</p><pre><code>MyTest=# \d products     Table &quot;public.products&quot;   Column     |  Type   | Modifiers ------------+---------+----------- product_no | integer | name          | text    | price           | numeric | Check constraints:    &quot;positive_price&quot; CHECK (price &gt; 0::numeric)</code></pre><p>和其他约束不同的是，非空约束没有名字，因此只能通过下面的方式删除：</p><pre><code>ALTER TABLE products ALTER COLUMN product_no DROP NOT NULL;</code></pre><h5 id="5-改变字段的缺省值"><a href="#5-改变字段的缺省值" class="headerlink" title="5. 改变字段的缺省值:"></a>5. 改变字段的缺省值:</h5><p>在为已有字段添加缺省值时，不会影响任何表中现有的数据行， 它只是为将来INSERT命令改变缺省值。</p><pre><code>ALTER TABLE products ALTER COLUMN price SET DEFAULT 7.77;</code></pre><p>下面为删除缺省值：</p><pre><code>ALTER TABLE products ALTER COLUMN price DROP DEFAULT</code></pre><h5 id="6-修改字段的数据类型："><a href="#6-修改字段的数据类型：" class="headerlink" title="6. 修改字段的数据类型："></a>6. 修改字段的数据类型：</h5><p>只有在字段里现有的每个项都可以用一个隐含的类型转换转换成新的类型时才可能成功。比如当前的数据都是整型，而转换的目标类型为numeric或varchar，这样的转换一般都可以成功。与此同时，PostgreSQL还将试图把字段的缺省值（如果存在）转换成新的类型， 还有涉及该字段的任何约束。但是这些转换可能失败，或者可能生成奇怪的结果。 在修改某字段类型之前，你最好删除那些约束，然后再把自己手工修改过的添加上去。</p><pre><code>ALTER TABLE products ALTER COLUMN price TYPE numeric(10,2);</code></pre><h5 id="7-修改字段名："><a href="#7-修改字段名：" class="headerlink" title="7. 修改字段名："></a>7. 修改字段名：</h5><pre><code>ALTER TABLE products RENAME COLUMN product_no TO product_number;</code></pre><h5 id="8-修改表名："><a href="#8-修改表名：" class="headerlink" title="8. 修改表名："></a>8. 修改表名：</h5><pre><code>ALTER TABLE products RENAME TO items;</code></pre><h4 id="四、权限："><a href="#四、权限：" class="headerlink" title="四、权限："></a>四、权限：</h4><p>只有表的所有者才能修改或者删除表的权限。要赋予一个权限，我们使用GRANT命令，要撤销一个权限，使用REVOKE命令。</p><p>需要指出的是，PUBLIC是特殊”用户”可以用于将权限赋予系统中的每一个用户。在声明权限的位置写ALL则将所有的与该对象类型相关的权限都赋予出去。</p><pre><code>GRANT UPDATE ON table_name TO user;  --将表的更新权限赋予指定的user。GRANT SELECT ON table_name TO GROUP group; --将表的select权限赋予指定的组。REVOKE ALL ON table_name FROM PUBLIC; --将表的所有权限从Public撤销。</code></pre><p>最初，只有对象所有者(或者超级用户)可以赋予或者撤销对象的权限。但是，我们可以赋予一个”with grant option”权限，这样就给接受权限的人以授予该权限给其它人的权限。如果授予选项后来被撤销，那么所有那些从这个接受者接受了权限的用户(直接或者通过级连的授权)都将失去该权限。</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PostgreSQL基础（一）：PostgreSQL 介绍</title>
      <link href="/posts/b218ff27/"/>
      <url>/posts/b218ff27/</url>
      
        <content type="html"><![CDATA[<p>PostgreSQL是以加州大学伯克利分校计算机系开发的POSTGRES， 版本 4.2为基础的对象关系型数据库管理系统（ORDBMS）。POSTGRES 领先的许多概念在很久以后才出现在一些商业数据库系统中。 </p><p>PostgreSQL是最初的伯克利代码的开源继承者。它支持大部分 SQL 标准并且提供了许多现代特性： </p><ul><li>复杂查询</li><li>外键</li><li>触发器</li><li>可更新视图</li><li>事务完整性</li><li>多版本并发控制</li></ul><p>同样，PostgreSQL可以用许多方法扩展，比如， 通过增加新的： </p><ul><li>数据类型</li><li>函数</li><li>操作符</li><li>聚集函数</li><li>索引方法</li><li>过程语言</li></ul><p>并且，因为自由宽大的许可证，任何人都可以以任何目的免费使用、修改和分发PostgreSQL， 不管是私用、商用还是学术研究目的。 </p><p>现在被称为PostgreSQL的对象-关系型数据库管理系统是从加州大学伯克利分校写的POSTGRES软件包发展而来的。经过二十多年的发展，PostgreSQL是世界上可以获得的最先进的开源数据库。 </p><h4 id="伯克利的POSTGRES项目"><a href="#伯克利的POSTGRES项目" class="headerlink" title="伯克利的POSTGRES项目"></a>伯克利的POSTGRES项目</h4><p>由Michael Stonebraker教授领导的POSTGRES项目是由防务高级研究项目局（DARPA）、陆军研究办公室（ARO）、国家科学基金（NSF） 以及 ESL, Inc 共同赞助的。 POSTGRES的实现始于 1986 年。该系统最初的概念详见 The design of POSTGRES 。 最初的数据模型定义见 The POSTGRES data model 。当时的规则系统设计在The design of the POSTGRES rules system里描述。存储管理器的理论基础和体系结构在 The design of the POSTGRES storage system 里有详细描述。 </p><p>从那以后，POSTGRES经历了几次主要的版本更新。 第一个”演示性”系统在 1987 年便可使用了， 并且在 1988 年的ACM-SIGMOD大会上展出。在 1989 年6月发布了版本 1（见 The implementation of POSTGRES ）给一些外部的用户使用。 为了回应用户对第一个规则系统（ A commentary on the POSTGRES rules system ）的批评，在1990年6月发布了使用新规则系统的版本 2。 版本 3 在1991年出现，增加了多存储管理器的支持， 并且改进了查询执行器、重写了规则系统。直到Postgres95发布前（见下文）的后续版本大多把工作都集中在移植性和可靠性上。 </p><p>POSTGRES已经被用于实现很多不同的研究和生产应用。这些应用包括： 一个财务数据分析系统、一个喷气引擎性能监控软件包、一个小行星跟踪数据库、一个医疗信息数据库和一些地理信息系统。POSTGRES还被许多大学用于教学用途。最后，Illustra Information Technologies（后来并入Informix， 而Informix现在被IBM所拥有） 拿到代码并使之商业化。在 1992 年末POSTGRES成为Sequoia 2000科学计算项目的主要数据管理器。 </p><p>在 1993 年间，外部用户社区的数量几乎翻番。随着用户的增加， 用于源代码维护的时间日益增加并占用了太多本应该用于数据库研究的时间，为了减少支持的负担，伯克利的POSTGRES项目在版本 4.2 时正式终止。 </p><h4 id="Postgres95"><a href="#Postgres95" class="headerlink" title="Postgres95"></a>Postgres95</h4><p>在 1994 年，Andrew Yu 和 Jolly Chen 向POSTGRES中增加了 SQL 语言的解释器。并随后用新名字Postgres95将源代码发布到互联网上供大家使用， 成为最初POSTGRES伯克利代码的开源继承者。 </p><p>Postgres95的源代码都是完全的 ANSI C，而且代码量减少了25%。许多内部修改提高了性能和可维护性。Postgres95的1.0.x版本在进行 Wisconsin Benchmark 测试时大概比POSTGRES的版本4.2 快 30-50%。除了修正了一些错误，下面的是一些主要提升： </p><p>原来的查询语言 PostQUEL 被SQL取代（在服务器端实现）。接口库libpq被按照PostQUEL命名。在PostgreSQL之前还不支持子查询（见下文），但它们可以在Postgres95中由用户定义的SQL函数模拟。聚集函数被重新实现。同时还增加了对GROUP BY 查询子句的支持。 </p><p>新增加了一个利用GNU的Readline进行交互 SQL 查询的程序（psql）。这个程序很大程度上取代了老的monitor程序。 </p><p>增加了新的前端库（libpgtcl）， 用以支持基于Tcl的客户端。一个样本 shell（pgtclsh），提供了新的 Tcl 命令用于Tcl程序和Postgres95服务器之间的交互。 </p><p>彻底重写了大对象的接口。保留了将大对象倒转（Inversion ）作为存储大对象的唯一机制（去掉了倒转（Inversion ）文件系统）。 </p><p>去掉了实例级的规则系统。但规则仍然以重写规则的形式存在。 </p><p>在发布的源码中增加了一个介绍SQL和Postgres95特性的简短教程。 </p><p>用GNU的make（取代了BSD的make）来编译。Postgres95可以使用不打补丁的GCC编译（修正了双精度数据对齐问题）。 </p><h4 id="PostgreSQL"><a href="#PostgreSQL" class="headerlink" title="PostgreSQL"></a>PostgreSQL</h4><p>到了 1996 年， 很明显”Postgres95”这个名字已经跟不上时代了。于是我们选择了一个新名字PostgreSQL来反映与最初的POSTGRES和最新的具有SQL能力的版本之间的关系。同时版本号也从 6.0 开始， 将版本号放回到最初由伯克利POSTGRES项目开始的序列中。 </p><p>很多人会因为传统或者更容易发音而继续用”Postgres”来指代PostgreSQL（现在很少用全大写字母）。这种用法也被广泛接受为一种昵称或别名。 </p><p>Postgres95的开发重点放在标识和理解后端代码的现有问题上。PostgreSQL的开发重点则转到了一些有争议的特性和功能上面，当然各个方面的工作同时都在进行。 </p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PostgreSQL </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
